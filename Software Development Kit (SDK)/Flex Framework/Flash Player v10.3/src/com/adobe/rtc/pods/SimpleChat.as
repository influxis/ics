/*
*
* ADOBE CONFIDENTIAL
* ___________________
*
* Copyright [2007-2010] Adobe Systems Incorporated
* All Rights Reserved.
*
* NOTICE:  All information contained herein is, and remains
* the property of Adobe Systems Incorporated and its suppliers,
* if any.  The intellectual and technical concepts contained
* herein are proprietary to Adobe Systems Incorporated and its
* suppliers and are protected by trade secret or copyright law.
* Dissemination of this information or reproduction of this material
* is strictly forbidden unless prior written permission is obtained
* from Adobe Systems Incorporated.
*/
package com.adobe.rtc.pods
{
	import com.adobe.coreUI.controls.ChatPullDown;
	import com.adobe.coreUI.controls.EmoticonTextArea;
	import com.adobe.coreUI.controls.NullColorPicker;
	import com.adobe.coreUI.controls.RichTextArea;
	import com.adobe.coreUI.localization.ILocalizationManager;
	import com.adobe.coreUI.localization.Localization;
	import com.adobe.coreUI.util.StringUtils;
	import com.adobe.rtc.events.ChatEvent;
	import com.adobe.rtc.events.CollectionNodeEvent;
	import com.adobe.rtc.events.UserEvent;
	import com.adobe.rtc.messaging.UserRoles;
	import com.adobe.rtc.session.IConnectSession;
	import com.adobe.rtc.session.ISessionSubscriber;
	import com.adobe.rtc.session.sessionClasses.SessionContainerProxy;
	import com.adobe.rtc.sharedManagers.UserManager;
	import com.adobe.rtc.sharedManagers.descriptors.UserDescriptor;
	import com.adobe.rtc.sharedModel.SimpleChatModel;
	import com.adobe.rtc.sharedModel.descriptors.ChatMessageDescriptor;
	
	import flash.events.ContextMenuEvent;
	import flash.events.Event;
	import flash.events.FocusEvent;
	import flash.events.KeyboardEvent;
	import flash.events.MouseEvent;
	import flash.events.TextEvent;
	import flash.ui.ContextMenu;
	import flash.ui.ContextMenuItem;
	import flash.ui.Keyboard;
	import flash.utils.Timer;
	
	import mx.collections.ArrayCollection;
	import mx.controls.Button;
	import mx.controls.ComboBox;
	import mx.controls.Label;
	import mx.controls.TextInput;
	import mx.core.ClassFactory;
	import mx.core.UIComponent;
	import mx.events.ColorPickerEvent;
	import mx.events.ScrollEvent;
	import mx.events.ScrollEventDetail;
	
	/**
	 * Dispatched when the chat pod goes in and out of sync.
	 */
	[Event(name="synchronizationChange", type="com.adobe.rtc.events.CollectionNodeEvent")]	
	/**
	 * The SimpleChat component is a high-level pod component which allows multiple users to 
	 * chat in a way that is similar to an instant messenger client. In the model-view-controller 
	 * sense, SimpleChat is the view 
	 * and controller to the SimpleChatModel's model since it consumes user events, drives them 
	 * to the model, accepts model events, and updates the view.
	 * <p>
	 * In general, users with a viewer role and higher can add and view messages.
	 * 
	 * @see com.adobe.rtc.sharedModel.SimpleChatModel
	 */
   public class  SimpleChat extends UIComponent implements ISessionSubscriber
	{
		/**
		 * @private
		 */
		protected static const SENT_QUEUE_MAX_LENGTH:int = 10;
				
		/**
		 * @private
		 */
		protected var _history:EmoticonTextArea;
		
		/**
		 * @private
		 */
		protected var _typingLabel:Label;
		
		/**
	     * @private
		 */
		protected var _newMessage:TextInput;

		/**
		 * @private
		 */
		protected var _colorPicker:NullColorPicker;
		
		/**
		 * @private
		 */
		protected var _model:SimpleChatModel;
		
		/**
		 * @private
		 */
		protected var _historyChanged:Boolean = false;
		
		/**
		 * @private
		 */
		protected var _typingChanged:Boolean = false;
		
		/**
		 * @private
		 */
		protected var _sizeChanged:Boolean = false;
		
		/**
		 * @private
		 */
		protected var _userManager:UserManager;
		
		/**
		 * @private
		 */
		protected var _toLabel:Label;
		
		/**
		 * @private
		 */
		protected var _toCombo:ComboBox;
		
		/**
		 * @private
		 */
		protected var _sendButton:Button;
		/**
		 * @private
		 */
		protected var _userListDirty:Boolean = false;		
		
		/**
		 * @private
		 */
		protected var _sentQueue:Array;
		
		/**
		 * @private
		 */
		protected var _sentQueueCurrentIndex:int;
		
		/**
		 * @private
		 */
		protected var _detachedScrolling:Timer;

		/**
		 * @private
		 */
		protected var _newMessageColor:uint = 0x000000;
		
		/**
		 * @private
		 */
		protected var _newMessageColorChanged:Boolean = true;

		/**
		 * @private
		 */
		protected var _historyFontSizeChanged:Boolean = true;
		
		[Inspectable(enumeration="false,true", defaultValue="false")]
		/**
		 * Specifies whether the <code>contextMenu</code> is supplied by the developer or should be generated by the component.
		 */
		public var useExternalContextMenu:Boolean = false;
		
		/**
		 * @private
		 */
		protected var _sessionDependent:Boolean = true;
		
		/**
		 * @private
		 */
		protected var _lm:ILocalizationManager = Localization.impl;
		
		/**
		 * @private
		 */
		protected var _messagesToAdd:String = "";
		/**
		 * @private
		 */
		protected var _groupName:String ;
		 /**
		 * @private
		 */
		protected var _sharedID:String ;
		 /**
		 * @private
		 */
		 private const DEFAULT_SHARED_ID:String =  "default_SimpleChat";
		/**
		 * @private
		 */
		protected var _subscribed:Boolean = false ;
		/**
		 * @private 
		 */		
		protected var _connectSession:IConnectSession = new SessionContainerProxy(this as UIComponent);
		/**
		 * @private
		 */
		protected var _historyFontSize:uint = 12;
            
		public function SimpleChat():void
		{			
			super();
		}
		
		/**
		 * @private
		 */
		override public function initialize():void
		{
			super.initialize();
			
			_sentQueue = [];
		}
		
		/**
		 * Returns the model for this chat pod. Most events and APIs for the 
		 * chat are exposed through the model.
		 */
		public function get model():SimpleChatModel
		{
			if (!_model) {
				subscribe();
			}
			return _model;
		}
		
		/**
		 * @private
		 */
		public function get historyTextArea():RichTextArea
		{
			return (_history) ? _history : null;
		}
		
		/**
		 * Specifies the color of incoming messages.
		 */
		public function get newMessageColor():uint
		{
			return _newMessageColor;
		}
		/**
		 * @private
		 */
		public function set newMessageColor(p_color:uint):void
		{
			_newMessageColor = p_color;
			_newMessageColorChanged = true;
			invalidateProperties();
		}

		/**
		 * Specifies the font size of the chat history.
		 */
		public function get historyFontSize():uint
		{
			return _model.historyFontSize;
		}
		/**
		 * @private
		 */
		public function set historyFontSize(p_size:uint):void
		{
			if ( _model && _model.isSynchronized ) {
				_historyFontSize = p_size ;
				_model.historyFontSize = p_size;
				_historyFontSizeChanged = true;
				invalidateProperties();
			}else {
				_historyFontSize = p_size ;
				_historyFontSizeChanged = true;
			}
		}
		
		/**
		 * @private 
		 */
		protected var _maxMessages:int = -1;
		/**
		 * @private 
		 */
		protected var _maxMessagesChanged:Boolean = false;
		
		/**
		 * @private
		 */
		public function set maxSavedMessages(p_max:int):void
		{
			_maxMessages = p_max;
			_maxMessagesChanged = true;
			invalidateProperties();
		}

		/**
		 * Specifies the number of messages that should be saved by the service. Only the last number of messages specified will be kept on the service;
		 * older messages are forgotten. Note that this only affects newcomers to the room - the chat client will remember all messages it has seen while
		 * it was in the room. Newcomers depend on the service to bring them "up to speed", so this will specify how much history is important for them
		 * to fetch upon their arrival. Also note, only a user with OWNER level credentials may set this property.
		 */
		public function get maxSavedMessages():int
		{
			return _maxMessages;
		}
			
		/**
		 * Defines the logical location of the component on the service, usually the <code>sharedID</code> of the collectionNode 
		 * the component uses. <code>sharedIDs</code> should be unique within a room if they're expressing two unique locations. 
		 * Note that this can only be assigned once and it is assigned before <code>subscribe()</code> is called. 
		 * For components with an <code class="property">id</code> property, <code>sharedID</code> defaults to that value.
		 */
		public function set sharedID(p_id:String):void
		{
			_sharedID = p_id;
		}
		
		/**
		 * @private
		 */
		public function get sharedID():String
		{
			return _sharedID;
		}

		/**
		 * The IConnectSession with which this component is associated. 
		 * Note that this may only be set once before <code>subscribe</code>
		 * is called; re-sessioning of components is not supported. 
		 * Defaults to the first IConnectSession created in the application.
		 */
		public function get connectSession():IConnectSession
		{
			return _connectSession;
		}
		
		/**
		 * Sets the IConnectSession with which this component is associated. 
		 * 
		 */
		public function set connectSession(p_session:IConnectSession):void
		{
			_connectSession = p_session;
		}
		
		/**
		 * @private
		 */
		public function set groupName(p_groupName:String):void
		{
			if ( p_groupName != _groupName ) {
				if (_model) {
					_model.close();
					_model.removeEventListener(CollectionNodeEvent.SYNCHRONIZATION_CHANGE, onSynchronizationChange);
					_model.removeEventListener(ChatEvent.HISTORY_CHANGE, onHistoryChange);
					_model.removeEventListener(ChatEvent.TYPING_LIST_UPDATE, onTypingListUpdate);
					_model.removeEventListener(ChatEvent.ALLOW_PRIVATE_CHAT_CHANGE, onAllowPrivateChange);
				}
				
				_model = null ;
				
				if ( _history ) {
					_history.htmlText = "" ;
				}
				
				if ( _newMessage ) {
					_newMessage.text = "" ;
				}
				
				_groupName = p_groupName ;
				subscribe();
			}
		}
		
		/**
		 * Components (pods) are assigned to a group via <code class="property">groupName</code>; if not specified, 
		 * the component is assigned to the default, public group (the room at large). Groups are like separate 
		 * conversations within the room, but each conversation could employ one or more pods; for example, one 
		 * "conversation" may use a web camera, chat, and whiteboard pod, with each pod using different access 
		 * and publish models. Users are members of and can only see components within the group they are assigned. 
		 * Room hosts can see all the groups and all the members in those groups.
		 */
		public function get groupName():String 
		{
			return _groupName;
		}
		
		[Inspectable(enumeration="false,true", defaultValue="false")]		
		/**
		 * Specifies whether the chat should be cleared upon the end of the session (true)  
		 * or whether it should persist on the service (false). 
		 * 
		 * @default true 
		 */
		public function get sessionDependent():Boolean
		{
			return _sessionDependent;
		}
		
		/**
		 * @private
		 */
		public function set sessionDependent(p_sessionDependent:Boolean):void
		{
			_sessionDependent = p_sessionDependent;
			//TODO: what do I do if this is called after createChildren?
		}
		
		[Bindable(event="synchronizationChange")]
		/**
		 * Determines whether the chat is connected and fully synchronized with the service.
		 */
		public function get isSynchronized():Boolean
		{
			return (_model != null && _model.isSynchronized);
		}
		
		/**
		 * Returns the entire chat history as a string.
		 */
		public function get htmlText():String
		{
			return _model.history;
		}
		
		
		/**
		 * Tells the component to begin synchronizing with the service. 
		 * For UIComponent-based components such as this one,
		 * <code>subscribe()</code> is called automatically upon being added to the <code>displayList</code>. 
		 * For "headless" components, this method must be called explicitly.
		 */
		public function subscribe():void
		{
			if ( !_model ) {
				
				// if the id is not set , then take default shared ID if it is not set not, else take the set shared id value
				// if id is set, then if shared id is not set, take set sharedID to id and take it, otherwise , take the set shared id
				
				if ( id == null ){
					if ( sharedID == null ) {
						sharedID = DEFAULT_SHARED_ID ;
					}
				}else {
					if ( sharedID == null ) {
						sharedID = id ;
					}
				}
				
				
		       if ( _groupName != null ) {
	            	sharedID += _groupName ;
	            }
	            
				_model = new SimpleChatModel(_sessionDependent);
				_model.sharedID = sharedID ;
				if ( _historyFontSizeChanged ) {
					_model.historyFontSize = _historyFontSize ;
				}
				if (_maxMessagesChanged) {
					_maxMessagesChanged = false;
					_model.maxSavedMessages = _maxMessages;
				}
				_model.connectSession = _connectSession ;	
				_model.subscribe();
				_model.addEventListener(CollectionNodeEvent.SYNCHRONIZATION_CHANGE, onSynchronizationChange);
				_model.addEventListener(ChatEvent.HISTORY_CHANGE, onHistoryChange);
				_model.addEventListener(ChatEvent.TYPING_LIST_UPDATE, onTypingListUpdate);
				_model.addEventListener(ChatEvent.ALLOW_PRIVATE_CHAT_CHANGE, onAllowPrivateChange);
		
			}
			
			if (!_userManager && _connectSession) {
				_userManager = _connectSession.userManager;
				_userManager.addEventListener(UserEvent.USER_CREATE, dirtyUserList);
				_userManager.addEventListener(UserEvent.USER_REMOVE, onUserRemove);
				_userManager.addEventListener(UserEvent.USER_ROLE_CHANGE, onUserRoleChange);
			}
			
		}
		
		
		
		/**
		 *  Sets the role of a given user for the chat.
		 * 
		 * @param p_userRole The role value to set on the specified user.
		 * @param p_userID The ID of the user whose role should be set.
		 */
		public function setUserRole(p_userID:String,p_userRole:int):void
		{
			if ( p_userID == null ) 
				return ;
				
			_model.setUserRole(p_userID,p_userRole);
		}
		
		
		/**
		 *  Returns the role of a given user for the chat.
		 * 
		 * @param p_userID The user ID for the user being queried.
		 */
		public function getUserRole(p_userID:String):int
		{
			if ( p_userID == null ) {
				throw new Error("CameraModel: USerId can't be null");
			}
			
			return _model.getUserRole(p_userID);
		}
		
		/**
		 * @private
		 * 
		 * CreateChildren. Creating the model and view and adding the event listeners and 
		 * setting the model in the view
		 */
		override protected function createChildren():void
		{
			super.createChildren();	
			
			if ( !_subscribed ) {
				subscribe();
				_subscribed = true ;
			
			}
			
			if (!_detachedScrolling) {
				_detachedScrolling = new Timer(5*1000, 1);
			}
			
			if (!_history) {
				_history = new EmoticonTextArea();
				_history.editable = false;
				_history.selectable = true;
				_history.matchEmoticons = true;
				_history.addEventListener("htmlTextChanged", onHtmlTextChange);
				_history.addEventListener(ScrollEvent.SCROLL, onHistoryScroll);
				_history.focusEnabled = false;
				_history.htmlText = "" ;
				addChild(_history);
			}

			if (!_newMessage) {
				_newMessage = new TextInput();
				_newMessage.maxChars = 1000;
				_newMessage.addEventListener(KeyboardEvent.KEY_DOWN, onKeyDown);
				//_newMessage.addEventListener(FlexEvent.ENTER, sendNewMessage);
				_newMessage.addEventListener(Event.CHANGE, onChange);
				_newMessage.addEventListener(FocusEvent.FOCUS_IN, onNewMessageFocusIn);	//it will get removed on the first focus-in
				_newMessage.htmlText = "<font color=\"#333333\"><i>"+_lm.getString("Enter chat here")+"</i></font>";
				addChild(_newMessage);
			}
			
			if (!_sendButton) {
				_sendButton = new Button();
				_sendButton.addEventListener(MouseEvent.CLICK, sendNewMessage);
				_sendButton.label = _lm.getString("Send");
				_sendButton.enabled = false;
				_sendButton.toolTip = _lm.getString("Send message");
				addChild(_sendButton);
			}
			
			if (!_colorPicker) {
				_colorPicker = new NullColorPicker();
				_colorPicker.allowNull = false;
				_colorPicker.dataProvider = [0x000000, 0x666666, 0x003366, 0x006699, 0x0033ff, 0x660066, 0x336666, 0x009933, 0x996600, 0x663300, 0xFF6600, 0xFF0000];
				_colorPicker.showTextField = false;
				_colorPicker.selectedColor = _newMessageColor;
				_colorPicker.setActualSize(22, 22);
				_colorPicker.toolTip = _lm.getString("color");
				_colorPicker.addEventListener(ColorPickerEvent.CHANGE, onColorPickerChange);
				_colorPicker.styleName = getStyle("colorPickerStyleName");
				addChild(_colorPicker);
			}
			
			if (!_toLabel) {
				_toLabel = new Label();
				_toLabel.text = _lm.getString("TO:");
				_toLabel.setStyle("color", 0xFFFFFF);
				_toLabel.setStyle("fontWeight", "bold");
				addChild(_toLabel);
			}
			
			if (!_toCombo) {
				_toCombo = new ComboBox();
				_toCombo.setStyle("fontFamily", "Arial");
				_toCombo.dropdownFactory = new ClassFactory(ChatPullDown);
				_toCombo.rowCount = 10;
				_toCombo.labelField = "displayName";
				_toCombo.dataProvider = [{displayName:_lm.getString("Everyone")}];
				_toCombo.editable = false;
				addChild(_toCombo);
				//update it once at the beginning
				dirtyUserList();
				updateToComboList();
			}
			
			

			if (!useExternalContextMenu) {
				createContextMenu();
			}
			
		}
		
		/**
		 * Disposes all listeners to the network and framework classes. Recommended for 
		 * proper garbage collection of the component.
		 */
		public function close():void
		{
			if (_colorPicker) {
				_colorPicker.removeEventListener(ColorPickerEvent.CHANGE, onColorPickerChange);
			}
			if (_history) {
				_history.removeEventListener("htmlTextChanged", onHtmlTextChange);
				_history.removeEventListener(ScrollEvent.SCROLL, onHistoryScroll);
			}
			
			if (_model) {
				_model.close();
				_model.removeEventListener(CollectionNodeEvent.SYNCHRONIZATION_CHANGE, onSynchronizationChange);
				_model.removeEventListener(ChatEvent.HISTORY_CHANGE, onHistoryChange);
				_model.removeEventListener(ChatEvent.TYPING_LIST_UPDATE, onTypingListUpdate);
				_model.removeEventListener(ChatEvent.ALLOW_PRIVATE_CHAT_CHANGE, onAllowPrivateChange);
			}
			
			if (_newMessage) {
				_newMessage.removeEventListener(KeyboardEvent.KEY_DOWN, onKeyDown);
				//_newMessage.removeEventListener(FlexEvent.ENTER, sendNewMessage);
				_newMessage.removeEventListener(Event.CHANGE, onChange);
			}
			
			if (_sendButton) {
				_sendButton.removeEventListener(MouseEvent.CLICK, sendNewMessage);
			}
			
			if (_userManager) {
				_userManager.removeEventListener(UserEvent.USER_CREATE, dirtyUserList);
				_userManager.removeEventListener(UserEvent.USER_REMOVE, onUserRemove);
				_userManager.removeEventListener(UserEvent.USER_ROLE_CHANGE, onUserRoleChange);			
			}
		}

			
		/**
		 * @private
		 */		
		protected function bubbleEvent(p_evt:Event):void
		{
			dispatchEvent(p_evt);
		}
		
		/**
		 * @private
		 */		
		protected function createContextMenu():void
		{
			if ( !_userManager ) {
				return ;
			}
			
			if (_model.getUserRole(_userManager.myUserID) == UserRoles.OWNER) {
	  			contextMenu = null;
				var cMenu:ContextMenu = new ContextMenu();
	       		cMenu.hideBuiltInItems();
				var item:ContextMenuItem = new ContextMenuItem(_lm.getString("Clear Chat History"));
				item.addEventListener(ContextMenuEvent.MENU_ITEM_SELECT, onClear);
				cMenu.customItems.push(item);
			 	item = new ContextMenuItem(_lm.getString("Save as..."));
				item.addEventListener(ContextMenuEvent.MENU_ITEM_SELECT, bubbleEvent);
				cMenu.customItems.push(item);
	        	contextMenu = cMenu;
	  		} else {
	  			contextMenu = null;
	  		}
		}
		
		/**
		 * @private
		 */		
		protected function onUserRoleChange(p_evt:UserEvent):void
		{
			if (!useExternalContextMenu) {
				createContextMenu();
			}	
		}
		
		/**
		 * @private
		 */		
		protected function onHistoryScroll(p_evt:ScrollEvent):void
		{
			if ( p_evt.detail == ScrollEventDetail.THUMB_TRACK ) {
				_detachedScrolling.reset();
				_detachedScrolling.start();
			}
			
		}
		
		/**
		 * @private
		 */		
		protected function onNewMessageFocusIn(p_evt:FocusEvent):void
		{
			_newMessage.removeEventListener(FocusEvent.FOCUS_IN, onNewMessageFocusIn);
			_newMessage.htmlText = null;
			_newMessage.validateNow();
			setSendButtonEnable();
		}
		
		/**
		 * @private
		 */		
		protected function setSendButtonEnable():void
		{
			_sendButton.enabled = !StringUtils.isEmpty(_newMessage.text) && _model.isSynchronized;
		}
		
		/**
		 * @private
		 */		
		protected function onUserRemove(p_evt:UserEvent):void
		{
			if (_toCombo.selectedItem && _toCombo.selectedItem.userID == p_evt.userDescriptor.userID) {
				_toCombo.selectedIndex = 0;
				_newMessage.htmlText = "";
				//ECR: have a sound indicator or something? 
			}
			dirtyUserList();
		}
		/**
		 * @private
		 */		
		protected function dirtyUserList(p_evt:UserEvent=null):void
		{
			_userListDirty = true;
			invalidateProperties();
		}
		
		/**
		 * @private
		 */		
		protected function updateToComboList(p_evt:Event=null):void
		{
			if (!_userListDirty || !_toCombo) {
				//nothing to do
				return;
			}
			
			//save the current selection
			var previousSelection:Object = {role:UserRoles.VIEWER};
			var currentSelection:Object = _toCombo.selectedItem;
			if (currentSelection) {
				if (currentSelection.role) {
					previousSelection = {role:currentSelection.role}; 
				} else {
					previousSelection = {userID:currentSelection.userID};
				}
			}
			 
			var a:ArrayCollection = new ArrayCollection();
			a.addItem({displayName:_lm.getString("Everyone"), role:UserRoles.VIEWER});
			a.addItem({displayName:_lm.getString("Hosts"), role:UserRoles.OWNER});
			if (_model.allowPrivateChat) {
				//TODO: how do I add a separator here?
				for each (var desc:UserDescriptor in _userManager.userCollection) {
					if (desc.userID == _userManager.myUserID) {
						continue;
					}
					a.addItem({displayName:desc.displayName, userID:desc.userID});
				}
			}
			
			_toCombo.dataProvider = a;
			
			//select it again
			var l:uint = a.length;
			for (var i:uint=0; i<l; i++) {
				if (previousSelection.role && previousSelection.role == a.getItemAt(i).role) {
					_toCombo.selectedIndex = i;
					break;
				} else if (previousSelection.userID && previousSelection.userID == a.getItemAt(i).userID) {
					_toCombo.selectedIndex = i;
					break;					
				}
			}
			
			_userListDirty = false;
		}

		/**
		 * @private
		 */		
		protected function updateTypingIfNeeded():void
		{
			if (_model.isSynchronized && _toCombo && _toCombo.selectedItem && _toCombo.selectedItem.role && _newMessage.text.length>0) {
				//don't show people you're typing if you're writing a private message
				//also don't update if the message is empty
				if ( _toCombo.selectedIndex == 0 ) {
					_model.iAmTyping();
				}
			}
		}
		
		
		/**
		 * @private
		 */		
		override protected function commitProperties():void
		{
			
			var historyClearMessage:String = "<font size=\""+_model.historyFontSize+"\" color=\"#666666\"><i>"+Localization.impl.getString("The chat history has been cleared.")+'\n'+"</i></font>";

			
			if (_historyChanged) {
				_historyChanged = false;
				if (_messagesToAdd=="" || _historyFontSizeChanged || _history.htmlText == historyClearMessage) {
					if (_historyFontSizeChanged) {
						_historyFontSizeChanged = false;
					}
					_history.htmlText = _model.history;
				} else {
					_history.htmlText += _messagesToAdd;
				}
				_messagesToAdd = "";
			}
			
			
			if (_typingChanged) {
				_typingChanged = false;
				var s:String = _model.usersTyping;
				if (s.length == 0) {
					if (_typingLabel) {
						removeChild(_typingLabel);
						_typingLabel = null;
						invalidateDisplayList();
					}
				} else {
					if (!_typingLabel) {
						_typingLabel = new Label();
						_typingLabel.setStyle("fontStyle", "italic");
						_typingLabel.setStyle("color", 0xCECECE);
						addChild(_typingLabel);
					}
					
					_typingLabel.text = _lm.formatString("USERS_TYPING", s);
					
					if ( _typingLabel.text == "USERS_TYPING") {
						_typingLabel.text = s + " is Typing" ;
					}
					
					invalidateDisplayList();
				}
			}
			
			if (_newMessageColorChanged && _colorPicker) {
				_newMessageColorChanged = false;
				_colorPicker.selectedColor = _newMessageColor;
				_newMessage.setStyle("color", _newMessageColor);
			}
			
			if (_maxMessagesChanged) {
				_maxMessagesChanged = false;
				_model.maxSavedMessages = _maxMessages;
			}
			
			if (_userListDirty) {
				updateToComboList();
			}
		}
	
		/**
		 * @private
		 */		
		override protected function measure():void
		{
			var padding:uint = 5;
			
			measuredWidth = measuredMinWidth = Math.max(_history.getExplicitOrMeasuredWidth(), _newMessage.getExplicitOrMeasuredWidth());
			measuredMinHeight = _history.getExplicitOrMeasuredHeight() + padding + _newMessage.getExplicitOrMeasuredHeight();
			if (_typingLabel) {
				measuredMinHeight += _typingLabel.getExplicitOrMeasuredHeight();
			}
			measuredHeight = measuredMinHeight;
			
			minWidth = 150 ;
			minHeight = 150 ;
			
			measuredMinWidth = 50;
			measuredMinHeight = 50;
			
			
		}
		
		/**
		 * @private
		 */		
		override public function setActualSize(w:Number, h:Number):void
		{
			_sizeChanged = (w != width || h != height);
			super.setActualSize(w, h);
		}		

		/**
		 * @private
		 */		
		protected function onSynchronizationChange(p_evt:CollectionNodeEvent):void
		{
			dispatchEvent(p_evt);
			
			if(!_model.isSynchronized) {	// disable network-dependent UI
				setSendButtonEnable();
			}else {
				if( _historyFontSizeChanged ) {
					_model.historyFontSize = _historyFontSize ;
					invalidateProperties();
				}
			}
			
			if ( _connectSession && _connectSession.archiveManager && _connectSession.archiveManager.isPlayingBack ) {
				if ( _newMessage ) {
					_newMessage.enabled = false ;
				}
				
				if ( _colorPicker ) {
					_colorPicker.enabled = false ;
				}
				
				if ( _toCombo ) {
					_toCombo.enabled = false ;
				}
			}
		}		
						
		/**
		 * @private
		 */		
		protected function onClear(p_evt:ContextMenuEvent):void
		{
			if (_model) {
				_model.clear();
			}
		}
		
		/**
		 * @private
		 */		
		protected function onHistoryChange(p_evt:ChatEvent):void
		{
			_historyChanged = true;
			if (p_evt.message) {
				if (_messagesToAdd == "") {
					_messagesToAdd = _model.formatMessageDescriptor(p_evt.message);
				} else {
					_messagesToAdd += _model.formatMessageDescriptor(p_evt.message);
				}
			}
			invalidateProperties();
			dispatchEvent(p_evt);
		}
		
		/**
		 * @private
		 */		
		protected function onTypingListUpdate(p_evt:Event):void
		{
			_typingChanged = true;
			invalidateProperties();	
		}
				
		/**
		 * @private
		 */		
		protected function onAllowPrivateChange(p_evt:Event):void
		{
			dirtyUserList();

			//if private chat gets disabled and we're in the middle of composing a private message,
			//go back to "Everyone" and delete my message
			if (!_model.allowPrivateChat && _toCombo && _toCombo.selectedItem && _toCombo.selectedItem.userID is String) {
				_toCombo.selectedIndex = 0;
				_newMessage.htmlText = "";
				//ECR: have a sound indicator or something? 
			}
		}
		
		/**
		 * @private
		 */		
		protected function onColorPickerChange(p_evt:ColorPickerEvent):void
		{
			_newMessageColor = _colorPicker.value as uint;
			_newMessage.setStyle("color", _newMessageColor);
			dispatchEvent(p_evt);
		}
		
		/**
		 * @private
		 */		
		protected function onChange(p_evt:Event):void
		{
			if (p_evt.target == _newMessage) {
				updateTypingIfNeeded();
				setSendButtonEnable();
			}
		}
		
		/**
		 * @private
		 */		
		protected function onHtmlTextChange(p_event:Event):void
		{
			if (!_detachedScrolling.running) {
				_history.removeEventListener(ScrollEvent.SCROLL, onHistoryScroll);
				_history.verticalScrollPosition = _history.maxVerticalScrollPosition; 
				_history.addEventListener(ScrollEvent.SCROLL, onHistoryScroll);
			}
		}
		
		/**
		 * @private
		 */		
		protected function sendNewMessage(p_evt:Event=null):void
		{
			var message:String = _newMessage.text;	//strips formatting

			if(_model.isSynchronized) {
			
				if (StringUtils.isEmpty(message)) {
					return;	//we don't send empty messages
				}
				
				if(_sentQueue.length >= SENT_QUEUE_MAX_LENGTH) {
					_sentQueue.pop();
				}
				_sentQueue.unshift(message);
				_sentQueueCurrentIndex = -1;
				var msg:ChatMessageDescriptor = new ChatMessageDescriptor(message);
				msg.color = _colorPicker.selectedColor;
								
				if (_toCombo.selectedItem.userID!=null) {
					// it's private
					msg.recipient = _toCombo.selectedItem.userID;
					msg.recipientDisplayName = _toCombo.selectedItem.displayName;
				} else {
					msg.role = _toCombo.selectedItem.role;
				}
				_model.sendMessage(msg);
				_newMessage.htmlText = "";
			}
		}
		
		
		
		/**
		 * @private
		 */		
		protected function onKeyDown(p_event:KeyboardEvent):void
		{
			if ( p_event.keyCode == Keyboard.ENTER ) {
				sendNewMessage();
				_newMessage.validateNow();
				return ;
			}
			
			if(p_event.keyCode == 38) {			// up arrow
				if(_sentQueue.length > 0 && _sentQueueCurrentIndex < _sentQueue.length - 1) {
					_sentQueueCurrentIndex++;
					_newMessage.htmlText = _sentQueue[_sentQueueCurrentIndex];
				}
			}
			else if(p_event.keyCode == 40) {	// down arrow
				if(_sentQueue.length > 0 && _sentQueueCurrentIndex > 0) {
					_sentQueueCurrentIndex--;
					_newMessage.htmlText = _sentQueue[_sentQueueCurrentIndex];
					_newMessage.setSelection(_newMessage.htmlText.length, _newMessage.htmlText.length);
				}
			}
			
			var nextKey:String = getNextKey(p_event);
			if (nextKey == 'Ctrl+Z' || nextKey == 'Ctrl+Y') {
				_newMessage.addEventListener(TextEvent.TEXT_INPUT, preventTyping);
			}

		}
		
		protected function preventTyping(p_event:TextEvent):void
		{
			p_event.preventDefault();
			_newMessage.removeEventListener(TextEvent.TEXT_INPUT, preventTyping);
		}
		
		
		/**
		 * @private
		 */ 
		protected function getNextKey(p_event:KeyboardEvent):String
		{
			var ctrlKey:String = "";
			if (p_event.ctrlKey) {
				ctrlKey += "Ctrl+";
			}
			
			ctrlKey += String.fromCharCode(p_event.charCode).toUpperCase();
			
			return ctrlKey;
		}


		/**
		 * @private
		 */		
		override protected function updateDisplayList(unscaledWidth:Number, unscaledHeight:Number):void
		{
			super.updateDisplayList(unscaledWidth, unscaledHeight);
			
			var BOTTOM_PADDING:uint = 3;
			var PADDING:uint = 6;
			var HORIZONTAL_PADDING:uint = 4;
			
			if (_sendButton) {
				_sendButton.setActualSize(_sendButton.measuredWidth, 47); 
				_sendButton.move(unscaledWidth-HORIZONTAL_PADDING-_sendButton.measuredWidth, unscaledHeight-BOTTOM_PADDING-_sendButton.height);
			}
			
			if (_colorPicker) {
				_colorPicker.move(_sendButton.x-HORIZONTAL_PADDING-_colorPicker.width, unscaledHeight-BOTTOM_PADDING-_colorPicker.height+1);
			}

			if (_newMessage) {
				_newMessage.setActualSize(_colorPicker.x-2*HORIZONTAL_PADDING, 21);
				_newMessage.move(HORIZONTAL_PADDING, unscaledHeight-BOTTOM_PADDING-_newMessage.height-1);
			}

			if (_toCombo) {
				var w:uint;
				w = Math.min(_toCombo.measuredWidth+10, _sendButton.x-2*HORIZONTAL_PADDING);
				_toCombo.setActualSize(w, 23);
				_toCombo.move(_sendButton.x-HORIZONTAL_PADDING-w, _newMessage.y-PADDING-_toCombo.height+3);
			}
			
			if (_toLabel) {
				_toLabel.setActualSize(_toLabel.measuredWidth, 22);
				var x:Number = _toCombo.x-_toLabel.measuredWidth-HORIZONTAL_PADDING;
				_toLabel.visible = (x>0);
				if (x>0) {
					_toLabel.move(x, _toCombo.y + (_toCombo.height-_toLabel.height)/2);
				}
			}

			if (_typingLabel) {
				var ww:Number = _toLabel.x - 2*HORIZONTAL_PADDING;
				_typingLabel.visible = (ww>40) && _toLabel.visible;
				if (ww>40) {
					_typingLabel.move(HORIZONTAL_PADDING, _toCombo.y);
					_typingLabel.setActualSize(ww, 19);
				}
			}			
			
			if (_history) {
				_history.setActualSize(unscaledWidth, _toCombo.y-PADDING);
			}
		}
	}
}
