<?php
/*************************************************************
 *************************************************************
 **
 ** Adobe LiveCycle Collaboration Service Account Management API
 **
 ** Revision
 **   $Revision: #11 $ - $Date: 2011/07/27 $
 **
 ** Author
 **   Raffaele Sena
 **
 ** Copyright
 **
 **   ADOBE SYSTEMS INCORPORATED
 **     Copyright 2007 Adobe Systems Incorporated
 **     All Rights Reserved.
 **
 **   NOTICE: Adobe permits you to use, modify, and distribute this file in accordance with the
 **   terms of the Adobe license agreement accompanying it.  If you have received this file from a
 **   source other than Adobe, then your use, modification, or distribution of it requires the prior
 **   written permission of Adobe.
 **
 *************************************************************
 *************************************************************/

/*****************************************************
 *
 * error thrown or generated by RTC API
 *
 */
class RTCError extends Exception {
}

/*****************************************************
 *
 * Constants for common user roles
 *
 */
interface RTCUserRole {
    const NONE = 0;
    const LOBBY = 5;
    const VIEWER = 10;
    const PUBLISHER = 50;
    const OWNER = 100;
}

/*****************************************************
 *
 * Constants for node configuration
 *
 */
interface NodeConfiguration {
    const STORAGE_SCHEME_SINGLE_ITEM = 0;
    const STORAGE_SCHEME_QUEUE       = 1;
    const STORAGE_SCHEME_MANUAL      = 2;
}

/*****************************************************
 *
 * a class that generates RTC authentication tokens
 *
 */
class RTCAuthenticator {

    private $authURL;

    function __construct($url) {
        $this->authURL = $url;
    }

    //
    // Get an RTC authentication token give login and password.
    //
    function login($user, $password, & $retHeaders) {
        $headers = array (
            "Content-Type" => 'text/xml'
        );

        $data = "<request><username>{$user}</username><password>{$password}</password></request>";

        $resp = RTC::http_post($this->authURL, $data, $headers);

        if (RTC::$DEBUG)
            echo "$resp\n";

        try {
            $result = new SimpleXMLElement($resp);
        } catch (Exception $e) {
            throw new RTCError("bad-response");
        }

        if ($result['status'] == "ok") {
            $auth = $result->authtoken;
            if ($auth['type'] == "COOKIE") {
                $retHeaders["Cookie"] = (string) $auth;
                return null;
            } else {
                $gak = base64_encode($auth);
                return "gak={$gak}";
            }
        } else
            throw new RTCError($resp);
    }

    //
    // Get a guest authentication token.
    //
    function guestLogin($user) {
        $guk = base64_encode("g:{$user}:");
        return "guk={$guk}";
    }
}

/*****************************************************
 *
 * a class that deals with meeting sessions and # external collaboration
 *
 */

class RTCSession {

    private $instance;
    private $account;
    private $room;
    private $secret;

    function __construct($instance, $account, $room) {
        $this->instance = str_replace("#room#", $room, $instance);
        $this->account = $account;
        $this->room = $room;
    }

    /**
     * get an external authentication token
     */
    function getAuthenticationToken($accountSecret, $name, $id, $role) {
        $role = (int) $role;
        if ($role < RTCUserRole::NONE || $role > RTCUserRole::OWNER)
            throw new RTCError("invalid-role");
        $utfname = utf8_encode($name);
        $token = "x:{$utfname}::{$this->account}:{$id}:{$this->room}:{$role}";
        $signature = $this->sign($accountSecret, $token);
        $signed = "{$token}:{$signature}";

        // unencoded
        // $ext = "ext={$signed}";

        // encoded
        $encoded = base64_encode($signed);
        $ext = "exx={$encoded}";

        return $ext;
    }

    /**
     * get the userId that the server will generate for this user
     */
    function getUserID($id) {
      return strtoupper("EXT-{$this->account}-{$id}");
    }

    function getSecret($baseURL, $authToken, $authHeaders) {
        $data = RTC::http_get("{$baseURL}app/session?instance={$this->instance}&{$authToken}", $authHeaders);

        if (RTC::$DEBUG)
            echo $data;

        $response = new SimpleXMLElement($data);
        $this->secret = (string) $response-> {
            'session-secret' };
    }

    function invalidate($baseURL, $authToken, $authHeaders) {
        $data = "action=delete&instance={$this->instance}&{$authToken}";
        $res = RTC::http_post("${baseURL}app/session", $data, $authHeaders);

        if (RTC::$DEBUG)
            echo $res;

        $this->instance = null;
        $this->account = null;
        $this->room = null;
        $this->secret = null;
    }

    private function sign($acctSecret, $data) {
        $key = "{$acctSecret}:{$this->secret}";

        // Calculate HMAC-SHA1 according to RFC2104
        // http://www.ietf.org/rfc/rfc2104.txt
        $blocksize = 64;
        $hashfunc = 'sha1';
        if (strlen($key) > $blocksize)
            $key = pack('H*', $hashfunc ($key));
        $key = str_pad($key, $blocksize, chr(0x00));
        $ipad = str_repeat(chr(0x36), $blocksize);
        $opad = str_repeat(chr(0x5c), $blocksize);
        $hmac = pack('H*', $hashfunc (($key ^ $opad) .
        pack('H*', $hashfunc (($key ^ $ipad) . $data))));
        return bin2hex($hmac);
    }
}

/*****************************************************
 *
 * A class that contains room or template item information.
 *
 */
class RTCItem {
    public $name;
    public $desc;
    public $created;

    function __construct($name, $desc, $created) {
        $this->name = $name;
        $this->desc = $desc;
        $this->created = date_create($created);
    }
}

/*****************************************************
 *
 * a class that deals with account information and provisioning
 *
 */
class RTCAccount {
    const ROOM_ITEMS = "meetings";
    const TEMPLATE_ITEMS = "templates";
    const ARCHIVE_ITEMS = "archives";

    public $url;
    private $authToken;
    private $authHeaders;
    private $authenticator;
    private $baseURL;
    private $contentPath;

    function contentURL() {
        return "{$this->baseURL}app/content{$this->contentPath}";
    }

    function __construct($url) {
        $this->url = $url;
        $this->authToken = null;
        $this->authHeaders = array ();
        $this->authenticator = null;
        $this->baseURL = null;
        $this->contentPath = null;
        $this->roomInstance = null;

        if (RTC::$DEBUG)
            echo RTC::$VERSION . "\n";

        $this->do_initialize();
    }

    function login($user, $password = null) {
        if ($password != null)
            $this->authToken = $this->authenticator->login($user, $password, $this->authHeaders);
        else
            $this->authToken = $this->authenticator->guestLogin($user);

        if (RTC::$DEBUG)
            print_r($this->authHeaders);

        $this->do_initialize();
    }

    //
    // keep the authentication token alive by accessing the account
    //
    function keepalive($user = null, $password = null) {
        $this->contentPath = null;
        if ($this->do_initialize())
            return true;
        if ($user)
            return $this->login($user, $password);
        return false;
    }

    //
    // create a room
    //
    function createRoom($room, $template = null, $deleteOnExit = false) {
        if (!$template)
            $template = "default";
        $data = "mode=xml&room={$room}&template={$template}";
		if ($deleteOnExit)
		    $data .= "&deleteonexit=true";
		if ($this->authToken)
		    $data .= "&{$this->authToken}";
        return RTC::http_post($this->url, $data, $this->authHeaders);
    }

    //
    // list rooms, templates, or archives
    //
    function listItems($type = null) {
        if ($type != RTCAccount::TEMPLATE_ITEMS && $type != RTCAccount::ARCHIVE_ITEMS)
            $type = RTCAccount::ROOM_ITEMS;

        $items = array ();
        $data = RTC::http_get("{$this->contentURL()}/{$type}/?{$this->authToken}", $this->authHeaders);

        try {
            $xml = new SimpleXMLElement($data);
        } catch (Exception $e) {
            throw new RTCError("bad-response");
        }

        foreach ($xml->children->node as $n) {
            $name = $n->name;
            $desc = $n->properties->xpath('property[@name = "cr:description"]');
            if (count($desc) > 0)
                $desc = $desc[0]->value;
            else
                $desc = null;
            $created = $n->properties->xpath('property[@name = "jcr:created"]');
            if (count($created) > 0)
                $created = $created[0]->value;
            else
                $created = null;

            $items[] = new RTCItem($name, $desc, $created);
        }

        return $items;
    }

    //
    // delete a room, a template, or an archive
    //
    function delete($item, $type = null, $list = FALSE) {
        if ($type != RTCAccount::TEMPLATE_ITEMS && $type != RTCAccount::ARCHIVE_ITEMS)
            $type = RTCAccount::ROOM_ITEMS;

        $curl = "{$this->contentURL()}/{$type}/{$item}";
        $limitCount = $list ? "" : "&count=0";
        $data = "action=delete&response=inline{$limitCount}&{$this->authToken}";
        return RTC::http_post($curl, $data, $this->authHeaders);
    }

    //
    // list rooms
    //
    function listRooms() {
        return $this->listItems(RTCAccount::ROOM_ITEMS);
    }

    //
    // list templates
    //
    function listTemplates() {
        return $this->listItems(RTCAccount::TEMPLATE_ITEMS);
    }

    //
    // list archives
    //
    function listArchives() {
        return $this->listItems(RTCAccount::ARCHIVE_ITEMS);
    }

    //
    // delete a room
    //
    function deleteRoom($r, $list = FALSE) {
        if ($r == null)
            throw new RTCError("parameter-required");
        return $this->delete(strtolower($r), RTCAccount::ROOM_ITEMS, $list);
    }

    //
    // delete a template
    //
    function deleteTemplate($t, $list = FALSE) {
        if ($t == null)
            throw new RTCError("parameter-required");
        return $this->delete(strtolower($t), RTCAccount::TEMPLATE_ITEMS, $list);
    }

    //
    // delete an archive
    //
    function deleteArchive($a, $list = FALSE) {
        if ($a == null)
            throw new RTCError("parameter-required");
        return $this->delete(strtolower($a), RTCAccount::ARCHIVE_ITEMS, $list);
    }

    //
    // Returns a room session for external authentication
    //
    function getSession($room) {
        $parts = explode('/', $this->url);
        $session = new RTCSession($this->roomInstance, $parts[count($parts) - 1], $room);
        $session->getSecret($this->baseURL, $this->authToken, $this->authHeaders);
        return $session;
    }

    //
    // invalidate room session
    //
    function invalidateSession($session) {
        $session->invalidate($this->baseURL, $this->authToken, $this->authHeaders);
    }

    //
    // Register endpoint URL for webhooks
    //
    function registerHook($endpoint = null, $token = null) {
        $acctid = explode('/', $this->roomInstance);
        $acctid = $acctid[0];
        $data = "account={$acctid}&action=registerhook";
        if ($endpoint != null)
            $data .= "&endpoint=" . urlencode($endpoint);
        if ($token)
            $data .= "&token=" . urlencode($token);
        $data .= "&{$this->authToken}";
        return RTC::http_post("{$this->baseURL}app/rtc", $data, $this->authHeaders);
    }

    //
    // Unregister endpoint URL
    //
    function unregisterHook() {
        return $this->registerHook();
    }

    // Return Registered Hook Info
    function getHookInfo() {
        $acctid = explode('/', $this->roomInstance);
        $acctid = $acctid[0];
        return RTC::http_get("{$this->baseURL}app/rtc?action=hookinfo&account={$acctid}&{$this->authToken}", $this->authHeaders);
    }

    //
    // Register endpoint URL for recording repository
    //
    function registerRepository($endpoint = null, $token = null) {
        $acctid = explode('/', $this->roomInstance);
        $acctid = $acctid[0];
        $data = "account={$acctid}&action=registerrepository";
        if ($endpoint != null)
            $data .= "&endpoint=" . urlencode($endpoint);
        if ($token)
            $data .= "&token=" . urlencode($token);
        $data .= "&{$this->authToken}";
        return RTC::http_post("{$this->baseURL}app/rtc", $data, $this->authHeaders);
    }

    //
    // Unregister endpoint URL for recording repository
    //
    function unregisterRepository() {
        return $this->registerRepository();
    }

    // Return Registered repository Info
    function getRepositoryInfo() {
        $acctid = explode('/', $this->roomInstance);
        $acctid = $acctid[0];
        return RTC::http_get("{$this->baseURL}app/rtc?action=repositoryinfo&account={$acctid}&{$this->authToken}", $this->authHeaders);
    }

    //
    // Start recording a specified room
    //
    function startRecording($room, $archiveId = '__defaultArchive__', $guestsAllowed = true) {
    	$itemBody = array('fullSession' => true, 'archiveID' => $archiveId, 'guestsAllowed' => $guestsAllowed);
        return $this->publishItem(
        	$room, "RoomManager", "roomState", array( 'itemID' => 'recordingState', 'body' => $itemBody ));
    }

    //
    // Stop recording a specified room
    //
    function stopRecording($room) {
        return $this->retractItem($room, "RoomManager", "roomState", "recordingState");
    }

    //
    // move an archive to a specified template
    //
    function moveArchive($archive, $template = null) {
    	$type = RTCAccount::ARCHIVE_ITEMS;
        $curl = "{$this->contentURL()}/{$type}/{$archive}";
        $data = "action=set-property&response=inline&name=cr:description";
        if ($template != null)
			$data .= "&value=" . urlencode($template);
        $data .= "&{$this->authToken}";
        return RTC::http_post($curl, $data, $this->authHeaders);
    }

    //
    // Subscribe to collection events
    //
    function subscribeCollection($room, $collection, $nodes = null) {
        $instance = str_replace("#room#", $room, $this->roomInstance);
        $params = "collection={$collection}";
        if ($nodes != null) {
            if (!is_array($nodes))
                $nodes = array (
                    $nodes
                );
            while (list ($i, $n) = each($nodes)) {
                $params .= "&node={$v}";
            }
        }
        $data = "&instance=$instance&action=subscribe&$params&$this->authToken";
        return RTC::http_post("{$this->baseURL}app/rtc", $data, $this->authHeaders);
    }

    //
    // Unubscribe from collection events
    //
    function unsubscribeCollection($room, $collection, $nodes = null) {
        $instance = str_replace("#room#", $room, $this->roomInstance);
        $params = "collection={$collection}";
        if ($nodes != null) {
            if (!is_array($nodes))
                $nodes = array (
                    $nodes
                );
            while (list ($i, $n) = each($nodes)) {
                $params .= "&node={$n}";
            }
        }
        $data = "instance={$instance}&action=subscribe&{$params}&{$this->authToken}";
        return RTC::http_post("{$this->baseURL}app/rtc", $data, $this->authHeaders);
    }

    //
    // Create node or collection
    //
    function createNode($room, $coll, $node, $configuration = null) {
        $instance = str_replace("#room#", $room, $this->roomInstance);
	$params = "instance={$instance}&action=configure&collection={$coll}&node={$node}&{$this->authToken}";

	if ($configuration != null) {
          $headers = array_merge($this->authHeaders, array ( "Content-Type" => 'text/xml' ));
          $data = "<request>" . RTC::array_toXML($configuration, "configuration") . "</request>";
          return RTC::http_post("{$this->baseURL}app/rtc?{$params}", $data, $headers);
        } else {
          return RTC::http_post("{$this->baseURL}app/rtc", $params, $this->authHeaders);
	}
    }

    //
    // Remove a node or collection
    //
    function removeNode($room, $coll, $node = null) {
        $instance = str_replace("#room#", $room, $this->roomInstance);
	$data = "instance={$instance}&action=remove&collection={$coll}";
	if ($node != null)
	    $data .= "&node={$node}";

	$data .= "&{$this->authToken}";
        return RTC::http_post("{$this->baseURL}app/rtc", $data, $this->authHeaders);
    }

    //
    // Configure a node
    //
    function setNodeConfiguration($room, $coll, $node, $configuration) {
        $instance = str_replace("#room#", $room, $this->roomInstance);
	$params = "instance={$instance}&action=configure&collection={$coll}&node={$node}&{$this->authToken}";

        $headers = array_merge($this->authHeaders, array ( "Content-Type" => 'text/xml' ));
        $data = "<request>" . RTC::array_toXML($configuration, "configuration") . "</request>";
        return RTC::http_post("{$this->baseURL}app/rtc?{$params}", $data, $headers);
    }

    //
    // Return the node configuration
    // """
    function getNodeConfiguration($room, $coll, $node) {
        $instance = str_replace("#room#", $room, $this->roomInstance);
        $path = "/{$coll}/nodes/{$node}/configuration";
        return RTC::http_get("{$this->baseURL}app/rtc?instance={$instance}&path={$path}&{$this->authToken}", $this->authHeaders);
    }

    //
    // Return the RTC items given collection and node
    //
    function fetchItems($room, $coll, $node, $items = null) {
        $instance = str_replace("#room#", $room, $this->roomInstance);
        $params = "instance={$instance}&collection=${coll}&node={$node}";
        if ($items != null) {
            if (!is_array($items))
                $items = array (
                    $items
                );
            while (list ($i, $it) = each($items)) {
                $params .= "&item={$it}";
            }
        }
        $params .= "&{$this->authToken}";
        return RTC::http_get("{$this->baseURL}app/rtc?{$params}", $this->authHeaders);
    }

    //
    // Publish an item
    //
    function publishItem($room, $collection, $node, $item, $overwrite = false) {
        $headers = array_merge($this->authHeaders, array ( "Content-Type" => 'text/xml' ));

        $instance = str_replace("#room#", $room, $this->roomInstance);
        $params = "instance={$instance}&action=publish&collection={$collection}&node={$node}";
        if ($overwrite) $params .= "&overwrite={$overwrite}";
        $params .= "&{$this->authToken}";
        $data = "<request>" . RTC::array_toXML($item, "item") . "</request>";

        return RTC::http_post("{$this->baseURL}app/rtc?{$params}", $data, $headers);
    }

    //
    // Retract an item
    //
    function retractItem($room, $collection, $node, $itemID) {
        $instance = str_replace("#room#", $room, $this->roomInstance);
        $data = "instance={$instance}&collection={$collection}&node={$node}&item={$itemID}&{$this->authToken}";
        return RTC::http_post("{$this->baseURL}app/rtc", $data, $this->authHeaders);
    }

    //
    // Set user role
    //
    function setUserRole($room, $userID, $role, $coll = null, $node = null) {
        $instance = str_replace("#room#", $room, $this->roomInstance);
	$data = "instance={$instance}&action=setrole&user={$userID}&role={$role}";

	if ($coll != null)
	    $data .= "&collection={$coll}";
	if ($coll != null)
	    $data .= "&node={$node}";

	$data .= "&{$this->authToken}";
        return RTC::http_post("{$this->baseURL}app/rtc", $data, $this->authHeaders);
    }

    //
    // Returns information about the account, if active
    //
    function getAccountInfo() {
        $acctid = explode('/', $this->roomInstance);
        $acctid = $acctid[0];
        $data = RTC::http_get("{$this->baseURL}app/account?account={$acctid}&{$this->authToken}", $this->authHeaders);
        return $data;
    }

    //
    // Returns information about the room/instance, if active
    //
    function getRoomInfo($room) {
        $instance = str_replace("#room#", $room, $this->roomInstance);
        $data = RTC::http_get("{$this->baseURL}app/account?instance={$instance}&{$this->authToken}", $this->authHeaders);
        return $data;
    }

    private function do_initialize() {
        if ($this->contentPath)
            return true;

        $data = RTC::http_get("{$this->url}?mode=xml&accountonly=true&{$this->authToken}", $this->authHeaders);

        if (RTC::$DEBUG)
            echo $data;

        try {
            $xml = new SimpleXMLElement($data);
        } catch (Exception $e) {
            throw new RTCError("bad-response");
        }

        if ($xml->getName() == "meeting-info") {
            $this->baseURL = '' . $xml->baseURL['href'];
            $this->url = rtrim($this->baseURL, '/') . parse_url($this->url, PHP_URL_PATH);
            $this->contentPath = '' . $xml->accountPath['href'];
            if ($xml->room)
                $this->roomInstance = '' . $xml->room['instance'];
            return true;
        }

        if ($xml->getName() == "result") {
            if ($xml['code'] == "unauthorized") {
                if ($xml->baseURL) {
		    $this->baseURL = '' . $xml->baseURL['href'];
		    $this->url = rtrim($this->baseURL, '/') . parse_url($this->url, PHP_URL_PATH);
                }

                $authURL = '' . $xml->authentication['href'];
                if (substr($authURL, 0, 1) == '/') {
                    $authURL = $this->baseURL . $authURL;
                }
                $this->authenticator = new RTCAuthenticator($authURL);
                return false;
            }
        }

        throw new RTCError($data);
    }
}

class RTC {
    public static $DEBUG = false;
    public static $USE_CURL = false;
    public static $VERSION = '$Revision: #11 $ - $Date: 2011/07/27 $';

    static function http_get($url, $headers = null) {
        if (RTC::$DEBUG) {
            echo "http_get: {$url}\n";
            if ($headers != null)
                print_r($headers);
        }

        if (RTC::$USE_CURL) {
            /*
             * use curl library
             */
            $req = curl_init($url);
            //if (RTC::$DEBUG) curl_setopt($req, CURLOPT_VERBOSE, true);
            curl_setopt($req, CURLOPT_RETURNTRANSFER, true);
            curl_setopt($req, CURLOPT_FOLLOWLOCATION, true);
            curl_setopt($req, CURLOPT_SSL_VERIFYPEER, false);

            if ($headers)
                curl_setopt($req, CURLOPT_HTTPHEADER, $headers);

            $resp = curl_exec($req);
            $error = curl_error($req);
            if ($error == "")
                $status = curl_getinfo($req, CURLINFO_HTTP_CODE);
            else
                $status = $error;

            curl_close($req);

            if ($error != "" && $status != 200)
                throw new RTCError($error);
            else
                return $resp;
        } else {
            /*
             * use streams
             */
            if ($headers == null)
                $header = '';
            else {
                $header = "";

                foreach ($headers as $name => $value) {
                    if ($header != "")
                        $header .= "\r\n";
                    $header = $header . $name . ": " . $value;
                }
            }

            $opts = array (
                'http' => array (
                    'method' => 'GET',
                    'header' => $header
                )
            );

            $context = stream_context_create($opts);

            $fp = fopen($url, 'r', false, $context);
            if (!$fp) {
                if (isset($http_response_header))
                    $headers = $http_response_header;
                else
                    throw new RTCError("connection-failed");
            } else {
                $meta = stream_get_meta_data($fp);
                $headers = $meta['wrapper_data'];
            }

            if (RTC::$DEBUG)
                print_r($headers);

            $statusLine = explode(' ', $headers[0], 3);

            if ($fp) {
                $resp = stream_get_contents($fp);
                fclose($fp);
            }

            if ($statusLine[1] == "200" | $statusLine[1] == "302")
                return $resp;
            else
                throw new RTCError($statusLine[1]);
        }
    }

    static function http_post($url, $params, $headers = null) {

        if (is_array($params))
            $data = http_build_query($params);
        else
            $data = $params;

        if (RTC::$DEBUG) {
            echo "http_post: {$url} {$data}\n";
            if ($headers != null)
                print_r($headers);

        }

        //$resp = "<h1>Request Successful</h1><br><p>" . "http_post: {$url} {$data}";

        if (RTC::$USE_CURL) {
            /*
             * use curl library
             */
            $req = curl_init($url);
            //if (RTC::$DEBUG) curl_setopt($req, CURLOPT_VERBOSE, true);
            curl_setopt($req, CURLOPT_RETURNTRANSFER, true);
            curl_setopt($req, CURLOPT_FOLLOWLOCATION, true);
            curl_setopt($req, CURLOPT_SSL_VERIFYPEER, false);
            curl_setopt($req, CURLOPT_POST, true);
            curl_setopt($req, CURLOPT_POSTFIELDS, $data);

            if ($headers)
                curl_setopt($req, CURLOPT_HTTPHEADER, $headers);

            $resp = curl_exec($req);
            $error = curl_error($req);
            if ($error == "")
                $status = curl_getinfo($req, CURLINFO_HTTP_CODE);
            else
                $status = $error;

            curl_close($req);

            if ($error != "" && $status != 200)
                throw new RTCError($error);

        } else {
            /*
             * use streams
             */

            if ($headers == null)
                $header = 'Content-type: application/x-www-form-urlencoded';
            else {
                $header = "";

                foreach ($headers as $name => $value) {
                    if ($header != "")
                        $header .= "\r\n";
                    $header = $header . $name . ": " . $value;
                }
            }

            $opts = array (
                'http' => array (
                    'method' => 'POST',
                    'header' => $header,
                    'content' => $data
                )
            );

            $context = stream_context_create($opts);

            $fp = fopen($url, 'r', false, $context);
            if (!$fp) {
                if (isset($http_response_header))
                    $headers = $http_response_header;
                else
                    throw new RTCError("connection-failed");
            } else {
                $meta = stream_get_meta_data($fp);
                $headers = $meta['wrapper_data'];
            }

            if (RTC::$DEBUG)
                print_r($headers);

            $statusLine = explode(' ', $headers[0], 3);

            if ($fp) {
                $resp = stream_get_contents($fp);
                fclose($fp);
            }

            if ($statusLine[1] != "200")
                throw new RTCError($statusLine[1]);
        }

        return $resp;
    }

    static function array_toXML($a, $root = null) {
        $result = '';
        if ($root != null) {
            if ($root == 'item') {
                 $id = array_key_exists('itemID', $a) ? $a['itemID'] : 'item';
                $result .= "<{$root} id=\"{$id}\">";
            } else
                $result .= "<{$root}>";
        }
        foreach($a as $name => $value) {
            if ($root == 'configuration')
                $result .= "<field var=\"{$name}\">";
            else
                $result .= "<property name=\"{$name}\">";
            $result .= '<value type="';
            if (is_array($value))
                 $result .= 'object';
            else if (is_string($value))
                 $result .= 'string';
            else if (is_float($value))
                 $result .= 'double';
            else if (is_int($value))
                 $result .= 'int';
            else if (is_bool($value))
                 $result .= 'boolean';
            else
                 //
                 // TODO: check for XML and binary data
                 //
                 $result .= 'unknown';
            $result .= '">';
            if (is_array($value))
                $result .= RTC::array_toXML($value);
            else if (is_string($value))
                $result .= $value;
            else
                $result .= var_export($value, true);
            $result .= '</value>';
            if ($root == 'configuration')
                $result .= '</field>';
            else
                $result .= '</property>';
        }
        if ($root != null)
            $result .= "</{$root}>";

        return $result;
    }
}

if (basename(__FILE__) == basename($_SERVER['SCRIPT_FILENAME'])) {

  //
  // running from the command-line and not as 'require(d)'
  //

  function usage($progname) {
    echo "usage: {$progname} [--debug] [--host=url] account user password command parameters...\n";
    echo "\n";
    echo "where <command> is:\n";
    echo "    --list\n";
    echo "    --create room [template]\n";
    echo "    --create-autodelete room [template]\n";
    echo "    --delete room\n";
    echo "    --delete-template template\n";
    echo "    --ext-auth secret room username userid role\n";
    echo "    --invalidate room\n";
    echo "\n";
    echo "    --get-node-configuration room collection node\n";
    echo "    --fetch-items room collection node\n";
    echo "    --register-hook endpoint [token]\n";
    echo "    --unregister-hook\n";
    echo "    --hook-info\n";
    echo "    --subscribe-collection room collection\n";
    echo "    --unsubscribe-collection room collection\n";
    echo "    --create-node room collection [node]\n";
    echo "    --remove-node room collection [node]\n";
    echo "    --set-user-role room userID role [collection [node]]\n";
    echo "    --publish-item room collection node itemID body\n";
    echo "    --retract-item room collection node itemID\n";
    echo "\n";
    echo "    --register-repository endpoint [token]\n";
    echo "    --unregister-repository\n";
    echo "    --repository-info\n";
    echo "    --start-recording room [[archiveId] [guestsAllowed]]\n";
    echo "    --stop-recording room\n";
    echo "    --delete-archive archive\n";
    echo "    --move-archive archive [template]\n";
    exit(1);
  }

  function getRole($role) {
    $role = strtolower($role);
    if ($role == "none")
      return RTCUserRole::NONE;
    else if ($role == "lobby")
      return RTCUserRole::LOBBY;
    else if ($role == "viewer")
      return RTCUserRole::VIEWER;
    else if ($role == "publisher")
      return RTCUserRole::PUBLISHER;
    else if ($role == "owner")
      return RTCUserRole::OWNER;
    else if (is_numeric($role))
      return intval($role);
    else
      throw new RTCError("invalid-role");
  }

  //
  // running from the command line
  //
  $args = $_SERVER['argv'];
  $progname = array_shift($args);

  $host = "http://collaboration.adobelivecycle.com";
  $accountName = "<YOUR DEVELOPER ACCOUNT NAME>";
  $username = "sdkuser";
  $password = "sdkpassword";

  while (count($args) > 0) {
    $arg = $args[0];

    if ($arg == "--debug")
      RTC::$DEBUG = true;

    else if (strncmp($arg, "--host=", 7) == 0)
      $host = substr($arg, 7);

    else if (strncmp($arg, "-", 1) == 0) {
      echo "invalid option: $arg\n";
      $args = array();
    }

    else
      break;

    array_shift($args);
  }

  if (count($args) < 3) {
    usage($progname);
  }

  $accountName = array_shift($args);
  $username = array_shift($args);
  $password = array_shift($args);

  $host = rtrim($host, '/');
  $accountURL = "{$host}/${accountName}";

  try {
    $am = new RTCAccount($accountURL);
    $am->login($username, $password);

    if (count($args) == 0 || $args[0] == "--list") {
      echo "==== template list for {$accountName} ====\n";
      foreach ($am->listTemplates() as $t) {
        echo "{$t->name}:{$t->created->format(DATE_RFC822)}\n";
      }

      echo "==== room list for {$accountName} ====\n";
      foreach ($am->listRooms() as $r) {
        echo "{$r->name}:{$r->desc}:{$r->created->format(DATE_RFC822)}\n";
      }

      echo "==== archive list for {$accountName} ====\n";
      foreach ($am->listArchives() as $a) {
        echo "{$a->name}:{$a->desc}:{$a->created->format(DATE_RFC822)}\n";
      }
    }

    else if ($args[0] == "--create") {
      $am->createRoom($args[1], count($args) > 2 ? $args[2] : null);
    }

    else if ($args[0] == "--create-autodelete") {
      $am->createRoom($args[1], count($args) > 2 ? $args[2] : null, true);
    }

    else if ($args[0] == "--delete") {
      $am->deleteRoom($args[1]);
    }

    else if ($args[0] == "--delete-template") {
      $am->deleteTemplate($args[1]);
    }

    else if ($args[0] == "--delete-archive") {
      $am->deleteArchive($args[1]);
    }

    else if ($args[0] == "--ext-auth") {
      if (count($args) >= 6)
        $role = getRole($args[5]);
      else
        $role = RTCUserRole::LOBBY;
      $session = $am->getSession($args[2]);
      $token = $session->getAuthenticationToken($args[1], $args[3], $args[4], $role);
      echo $token . "\n";
    }

    else if ($args[0] == "--info") {
      if (count($args) == 1) {
        echo $am->getAccountInfo();
      } else {
        echo $am->getRoomInfo($args[1]);
      }
    }

    else if ($args[0] == "--get-node-configuration") {
      echo $am->getNodeConfiguration($args[1], $args[2], $args[3]);
    }

    else if ($args[0] == "--fetch-items") {
      echo $am->fetchItems($args[1], $args[2], $args[3]);
    }

    else if ($args[0] == "--register-hook") {
      if (count($args) > 2)
        echo $am->registerHook($args[1], $args[2]);
      else
        echo $am->registerHook($args[1]);
    }

    else if ($args[0] == "--unregister-hook") {
      echo $am->unregisterHook();
    }

    else if ($args[0] == "--hook-info") {
      echo $am->getHookInfo();
    }

    else if ($args[0] == "--register-repository") {
      if (count($args) > 2)
        echo $am->registerRepository($args[1], $args[2]);
      else
        echo $am->registerRepository($args[1]);
    }

    else if ($args[0] == "--unregister-repository") {
      echo $am->unregisterRepository();
    }

    else if ($args[0] == "--repository-info") {
      echo $am->getRepositoryInfo();
    }

    else if ($args[0] == "--start-recording") {
      if (count($args) > 3)
        echo $am->startRecording($args[1], $args[2], $args[3]);
      else if (count($args) > 2)
        echo $am->startRecording($args[1], $args[2]);
      else
        echo $am->startRecording($args[1]);
    }

    else if ($args[0] == "--stop-recording") {
      echo $am->stopRecording($args[1]);
    }

    else if ($args[0] == "--move-archive") {
      if (count($args) > 2)
        echo $am->moveArchive($args[1], $args[2]);
      else
        echo $am->moveArchive($args[1]);
    }

    else if ($args[0] == "--subscribe-collection") {
      if (count($args) > 3)
        echo $am->subscribeCollection($args[1], $args[2], $args[3]);
      else
        echo $am->subscribeCollection($args[1], $args[2]);
    }

    else if ($args[0] == "--unsubscribe-collection") {
      if (count($args) > 3)
        echo $am->unsubscribeCollection($args[1], $args[2], $args[3]);
      else
        echo $am->unsubscribeCollection($args[1], $args[2]);
    }

    else if ($args[0] == "--publish-item") {
      echo $am->publishItem($args[1], $args[2], $args[3],
        array( 'itemID' => $args[4], 'body' => $args[5] ));
    }

    else if ($args[0] == "--retract-item") {
      echo $am->retractItem($args[1], $args[2], $args[3], $args[4]);
    }

    else if ($args[0] == "--create-node") {
      echo $am->createNode($args[1], $args[2], $args[3]);
    }

    else if ($args[0] == "--remove-node") {
      if (count($args) > 3)
        echo $am->removeNode($args[1], $args[2], $args[3]);
      else
        echo $am->removeNode($args[1], $args[2]);
    }

    else if ($args[0] == "--set-user-role") {
      $role = getRole($args[3]);

      if (count($args) > 5)
        echo $am->setUserRole($args[1], $args[2], $role, $args[4], $args[5]);
      else if (count($args) > 4)
        echo $am->setUserRole($args[1], $args[2], $role, $args[4]);
      else
        echo $am->setUserRole($args[1], $args[2], $role);
    }

    else {
      usage($progname);
    }

  } catch(RTCError $e) {
    echo "Error: {$e}";
  }
}

?>
