#!env ruby
#
# = Synopsis
#
# This library allows you to connect to the Adobe LiveCycle Collaboration Service and
# manage an account, including listing rooms and templates, creating new rooms, and
# deleting rooms and templates.
#
# == Examples
#
#   require 'lccs'
#
#   # 
#   # Create a new account manager object using your account URL. This URL is displayed
#   # in the Developer Portal when you log in.
#   #  
#   am = RTC::AccountManager.new("http://collaboration.adobelivecycle.com/<YOUR DEVELOPER ACCOUNT NAME>")
#   
#   # 
#   # Use the login method to log in with your developer account's username and password.
#   # 
#   am.login(accountowner, accountpassword)
#
#   #
#   # Use the keepalice method to keep the authentication token alive
#   #
#   am.keepalive(accountowner, accountpassword)
#
#   # 
#   # Use the provided methods to list, create, and delete rooms and templates on-the-fly.
#   # 
#   rooms = am.listRooms()
#   templates = am.listTemplates()
#   am.createRoom("newRoom")
#   am.deleteRoom("newRoom")
#   am.createRoom("newRoom", "fromTemplate")
#   am.createRoom("newRoom", "fromTemplate", deleteOnExit)
#   am.deleteTemplate("fromTemplate")
#
#   #
#   # External authentication
#   #
#   session = am.getSession("room1")
#   secret = "account-shared-secret"
#   puts session.getAuthenticationToken(secret, "raff", "x-raff", 100)
#   puts session.getAuthenticationToken(secret, "bob", "x-bob", 50)
#   puts session.getAuthenticationToken(secret, "bill", "x-bill", 5)
#
#   am.invalidateSession(session)
#
#   #
#   # Account and room info
#   #
#   puts am.getAccountInfo()
#   puts am.getRoomInfo("room").inspect
#   puts am.getRoomInfo("accountident/room").inspect
#
#   #
#   # Collection and node info
#   #
#   puts am.getNodeConfiguration("room", "CollectionName", "NodeName").inspect
#   puts am.fetchItems("room", "CollectionName", "NodeName").inspect
#   puts am.publishItem("room", "CollectionName", "NodeName", item)
#
#   #
#   # Events handling
#   #
#   puts am.registerHook("http://hook.endpoint.url", "securityToken")
#   puts am.subscribeCollection("room", "CollectionName")
#
# = Revision
#   $Revision: #7 $ - $Date: 2011/07/20 $
#
# = Author
#
#   Raffaele Sena
#
# = Copyright
#
#   ADOBE SYSTEMS INCORPORATED
#     Copyright 2007 Adobe Systems Incorporated
#     All Rights Reserved.
#
#   NOTICE: Adobe permits you to use, modify, and distribute this file in accordance with the 
#   terms of the Adobe license agreement accompanying it.  If you have received this file from a 
#   source other than Adobe, then your use, modification, or distribution of it requires the prior 
#   written permission of Adobe.
#
require "base64"
require "digest/md5"
require "date"
require "rexml/document"
require "openssl"

module RTC

  DEBUG = false
  VERSION = "$Revision: #8 $ - $Date: 2013/04/04 $"

  #
  # An error thrown or generated by the RTC API.
  #
  class Error < StandardError
  end

  # 
  # Constants for common user roles. These are mirrored in the Room Console as well.
  # 
  class UserRole
    NONE      = 0
    LOBBY     = 5
    VIEWER    = 10
    PUBLISHER = 50
    OWNER     = 100
  end
  
  #
  # Constants for node configuration
  #
  class NodeConfiguration
    STORAGE_SCHEME_SINGLE_ITEM = 0
    STORAGE_SCHEME_QUEUE       = 1
    STORAGE_SCHEME_MANUAL      = 2
  end

  #####################################################
  #
  # A class that generates RTC authentication tokens.
  #
  class Authenticator
    def initialize(url)
      @authURI = URI.parse(url)
    end

    #
    # Get an RTC authentication token give login and password.
    #
    def login(user, password, authHeaders)
      headers = { "Content-Type" => "text/xml" };
      data = """
        <request>
          <username>#{user}</username>
          <password>#{password}</password>
        </request>
      """
      
      resp = RTC::http_post(@authURI, data, headers)

      response = REXML::Document.new(resp).root
      if response.attributes['status'] == "ok"
        authToken = response.elements['authtoken']
      	if authToken.attributes['type'] == "COOKIE"
      	  authHeaders['Cookie'] = authToken.text
      	  token = nil
        else
          auth = authToken.text
          gak = Base64.encode64(auth).gsub("\n","")
      	  token = "gak=#{gak}"
        end

      	puts "token: #{token}, auth:#{auth}, headers:#{authHeaders.inspect}" if RTC::DEBUG
      	return token
      else
        raise RTC::Error, resp
      end
    end

    #
    # Get a guest authentication token.
    #
    def self.guestLogin(user)
      guk = Base64.encode64("g:#{user}:").gsub("\n","")
      return "guk=#{guk}"
    end
  end

  #####################################################
  #
  # A class that deals with meeting sessions and
  # external authentication.
  #
  class Session
    #
    # Get an external authentication token.
    #
    def getAuthenticationToken(accountSecret, name, id, role)
      token = "x:#{name}::#{@account}:#{id}:#{@room}:#{role.to_i}"
      signed = "#{token}:#{sign(accountSecret, token)}"

      # unencoded
      #return "ext=#{signed}"

      # encoded
      enc = Base64.encode64(signed).gsub("\n","")
      return "exx=#{enc}"
    end

    #
    # Get the userId that the server will generate for this user
    #
    def getUserID(id)
      return "EXT-#{@account}-#{id}".upcase
    end
    
    #:stopdoc:

    def initialize(instance, account, room)
      begin
        @instance = instance.gsub(/#room#/, room)
      rescue
        @instance = instance
      end
      
      @account = account
      @room = room
      @digest = OpenSSL::Digest::Digest.new('SHA1')
    end

    def getSecret(baseURL, authToken, authHeaders)
      data = RTC::http_get("#{baseURL}app/session?instance=#{@instance}&#{authToken}", authHeaders)
      puts data if RTC::DEBUG

      response = REXML::Document.new(data).root
      @secret = response.elements['session-secret'].text
    end

    def invalidate(baseURL, authToken, authHeaders)
      data = "action=delete&instance=#{@instance}&#{authToken}"
      res = RTC::http_post("#{baseURL}app/session", data, authHeaders)
      puts res if RTC::DEBUG

      @instance = nil
      @account = nil
      @room = nil
      @digest = nil
      @secret = nil

      response = REXML::Document.new(res).root
      RTC::check_status response
    end

    def marshal_dump
      [@instance, @account, @room, @secret]
    end

    def marshal_load(data)
      @instance = data.shift
      @account  = data.shift
      @room     = data.shift
      @secret   = data.shift
      @digest = OpenSSL::Digest::Digest.new('SHA1')
    end

    protected
      def sign(acctSecret, data)
        return OpenSSL::HMAC.hexdigest(@digest, 
          "#{acctSecret}:#{@secret}", data)
      end

    #:startdoc:#:
  end

  #####################################################
  #
  # A class that contains room or template item information.
  #
  class Item
    protected
      def initialize(name, desc, created)
        @name = name
        @desc = desc
        @created = created.nil? ? nil : DateTime.parse(created)
      end

    public
      attr_reader :name, :desc, :created
      alias_method :templatename, :desc
  end
 
  #####################################################
  #
  # A class that contains room session info
  #
  class RoomInfo
    attr_accessor :isConnected, :userCount, :bytesUp, :bytesDown, :messages, :peakUsers, 
	:dateCreated, :dateStarted, :dateEnded, :dateExpired
  end

  #####################################################
  #
  # A class that contains account session info
  #
  class AccountInfo
    attr_accessor :userCount, :peakUserCount, :bytesUp, :bytesDown, :messages,
	:userTime, :dateCreated, :dateExpired, :activeRooms
  end

  #####################################################
  #
  # A class that deals with account information and provisioning.
  #
  class AccountManager
    public
      ROOM_ITEMS     = "meetings"
      TEMPLATE_ITEMS = "templates"
      ARCHIVE_ITEMS  = "archives"

      def url
        @url
      end

      def contentURL
        "#{@baseURL}app/content#{@contentPath}"
      end

      def initialize(url)
        @url = url
        @authToken = nil
        @authHeaders = {}
        @authenticator = nil
        @baseURL = nil
        @contentPath = nil
        @roomInstance = nil

        puts VERSION if DEBUG

        do_initialize
      end

      #
      # Login and connect to the account
      #
      def login(user, password = nil)
        if password != nil
          @authToken = @authenticator.login(user, password, @authHeaders)
        else
          @authToken = Authenticator.guestLogin(user)
        end

        do_initialize
      end

      #
      # Keep the authentication token alive by accessing the account.
      #
      # If the requerst fails with an authentication error
      # and credentials are provided, this method will authenticated again
      # 
      def keepalive(user = nil, password = nil)
        @contentPath = nil
        return true if do_initialize
        return login(user, password) if user
        return false
      end

      #
      # Create a room. If no template is specified, use the default, empty template.
      #
      def createRoom(room, template = nil, deleteOnExit = false)
        template = "default" if !template
        data = "mode=xml&room=#{room}&template=#{template}"
        data << "&deleteonexit=true" if deleteOnExit
        data << "&#{@authToken}" if @authToken
        res = RTC::http_post(@url, data, @authHeaders)
	      puts res if RTC::DEBUG

        response = REXML::Document.new(res).root
	      if response.local_name != "meeting-info"
          raise RTC::Error, res
        else
          return "ok"
        end
      end

      #
      # List rooms, templates, or archives.
      #
      def list(type = ROOM_ITEMS)
        case type
          when ROOM_ITEMS
          when TEMPLATE_ITEMS
          when ARCHIVE_ITEMS
          else
            raise RTC::Error, "invalid-type"
        end

        data = RTC::http_get("#{contentURL}/#{type}/?#{@authToken}", @authHeaders)

        items = Array.new

        response = REXML::Document.new(data).root
        response.elements.each("children/node") {
          |n|

          name = n.elements["name"].text
          desc = n.elements["properties/property[@name = 'cr:description']"]
          desc = desc.elements["value"].text if desc
          created = n.elements["properties/property[@name = 'jcr:created']"]
          created = created.elements["value"].text if created

          items.push(Item.new(name, desc, created))
        }

	      return items
      end

      #
      # Delete a room, a template, or an archive.
      #
      def delete(item, type = ROOM_ITEMS, list = false)
        case type
          when ROOM_ITEMS
          when TEMPLATE_ITEMS
          when ARCHIVE_ITEMS
          else
            raise RTC::Error, "invalid-type"
        end

        durl = "#{contentURL}/#{type}/#{item}"

      	if list
      	  limitCount = ""
      	else
      	  limitCount = "&count=0"
      	end

        data = "action=delete&response=inline#{limitCount}&#{@authToken}"
        res = RTC::http_post(durl, data, @authHeaders)
        puts res if RTC::DEBUG

        response = REXML::Document.new(res).root
        return response
      end

      #
      # List rooms.
      #
      def listRooms()
        return list(ROOM_ITEMS)
      end

      #
      # List templates.
      #
      def listTemplates()
        return list(TEMPLATE_ITEMS)
      end

      #
      # List archives.
      #
      def listArchives()
        return list(ARCHIVE_ITEMS)
      end
      
      #
      # Delete a room.
      #
      def deleteRoom(r, list = false)
        raise RTC::Error, "parameter-required" if r.nil?
        return delete(r.downcase, ROOM_ITEMS, list)
      end

      #
      # Delete a template.
      #
      def deleteTemplate(t, list = false)
        raise RTC::Error, "parameter-required" if t.nil?
        return delete(t, TEMPLATE_ITEMS, list)
      end

      #
      # Delete an archive.
      #
      def deleteArchive(a, list = false)
        raise RTC::Error, "parameter-required" if a.nil?
        return delete(a, ARCHIVE_ITEMS, list)
      end      

      #
      # Return a room session for external authentication.
      #
      def getSession(room)
        session = Session.new(@roomInstance, url.split("/")[-1], room)
      	session.getSecret(@baseURL, @authToken, @authHeaders)
      	return session
      end

      #
      # Invalidate the room session.
      #
      def invalidateSession(session)
        session.invalidate(@baseURL, @authToken, @authHeaders)
      end

      #
      # Return the node configuration
      #
      def getNodeConfiguration(room, coll, node)
        begin
          instance = @roomInstance.gsub(/#room#/, room)
        rescue
          instance = @roomInstance
        end
      	path = "/#{coll}/nodes/#{node}/configuration"
        data = RTC::http_get("#{@baseURL}app/rtc?instance=#{instance}&path=#{path}&#{@authToken}", @authHeaders)
      	puts data if RTC::DEBUG

              response = REXML::Document.new(data).root
      	RTC::check_status response
      	
      	coll = response.elements["collections/node"]
      	raise RTC::Error, "invalid-collection" if coll.nil?
      	node = coll.elements["collection/nodes/node"]
      	raise RTC::Error, "invalid-node" if node.nil?

        return RTC::from_xml(node.elements["collection/configuration"])
      end

      #
      # Return the RTC nodes @ path.
      #
      def fetchItems(room, coll, node, items=nil)
        begin
          instance = @roomInstance.gsub(/#room#/, room)
        rescue
          instance = @roomInstance
        end
        
        params = "instance=#{instance}&collection=#{coll}&node=#{node}"
        if !items.nil?
          items = items.to_a
          params << items.unshift("").join("&item=") if items.length > 0
        end   
        params << "&#{@authToken}"
        
        data = RTC::http_get("#{@baseURL}app/rtc?#{params}", @authHeaders)
      	puts data if RTC::DEBUG 

        response = REXML::Document.new(data).root
      	RTC::check_status response

      	coll = response.elements["collections/node"]
      	raise RTC::Error, "invalid-collection" if coll.nil?
      	node = coll.elements["collection/nodes/node"]
      	raise RTC::Error, "invalid-node" if node.nil?

        return RTC::from_xml(node.elements["collection/items"])
      end
      
      #
      # Register endpoint URL for webhooks
      #
      def registerHook(endpoint=nil, token=nil)
        acctid = @roomInstance.split("/")[0]
        data = "account=#{acctid}&action=registerhook"
        data << "&endpoint=#{RTC.url_escape(endpoint)}" if endpoint
        data << "&token=#{RTC.url_escape(token)}" if token
        data << "&#{@authToken}"
        res = RTC::http_post("#{@baseURL}app/rtc", data, @authHeaders)
        puts res if RTC::DEBUG

        response = REXML::Document.new(res).root
        RTC::check_status response
      end
      
      #
      # Unregister endpoint URL for webhooks
      #
      def unregisterHook
        return registerHook()
      end
        
      #
      # Return the webhook information
      #
      def getHookInfo()
        acctid = @roomInstance.split("/")[0]
        data = RTC::http_get("#{@baseURL}app/rtc?action=hookinfo&account=#{acctid}&#{@authToken}", @authHeaders)
        puts data if RTC::DEBUG

        response = REXML::Document.new(data).root
	      RTC::check_status response

      	return {
      	  'endpoint' => response.elements["param[@name='registerHookEndpoint']"].text,
      	  'token' => response.elements["param[@name='registerHookToken']"].text
      	}
      end

      #
      # Register endpoint URL for recording repository
      #
      def registerRepository(endpoint=nil, token=nil)
        acctid = @roomInstance.split("/")[0]
        data = "account=#{acctid}&action=registerrepository"
        data << "&endpoint=#{RTC.url_escape(endpoint)}" if endpoint
        data << "&token=#{RTC.url_escape(token)}" if token
        data << "&#{@authToken}"
        res = RTC::http_post("#{@baseURL}app/rtc", data, @authHeaders)
        puts res if RTC::DEBUG

        response = REXML::Document.new(res).root
        RTC::check_status response
      end
      
      #
      # Unregister endpoint URL for recording repository
      #
      def unregisterRepository
        return registerRepository()
      end
        
      #
      # Return the repository information
      #
      def getRepositoryInfo()
        acctid = @roomInstance.split("/")[0]
        data = RTC::http_get("#{@baseURL}app/rtc?action=repositoryinfo&account=#{acctid}&#{@authToken}", @authHeaders)
        puts data if RTC::DEBUG

        response = REXML::Document.new(data).root
        RTC::check_status response

        return {
          'endpoint' => response.elements["param[@name='repositoryEndpoint']"].text,
          'token' => response.elements["param[@name='repositoryToken']"].text
        }
      end
      
      #
      # Start recording a specified room
      #
      def startRecording(room, archiveId, guestsAllowed = true)
        itemBody = { "fullSession" => true, "archiveID" => archiveId, "guestsAllowed" => guestsAllowed }
        itemVO = { "itemID" => "recordingState", "body" => itemBody }
        return publishItem(room, 'RoomManager', 'roomState', itemVO)
      end
      
      #
      # Stop recording a specified room
      #
      def stopRecording(room)
        return retractItem(room, 'RoomManager', 'roomState', 'recordingState')
      end
      
      #
      # Move an archive to a specified template
      #
      def moveArchive(archive, template=nil)
        type = ARCHIVE_ITEMS
        durl = "#{contentURL}/#{type}/#{archive}"
        
        data = "action=set-property&response=inline&name=cr:description"
        data << "&value=#{template}" if template
        data << "&#{@authToken}"
  
        res = RTC::http_post(durl, data, @authHeaders)
        puts res if RTC::DEBUG

        response = REXML::Document.new(res).root
        return response
      end
      
      #
      # Subscribe to collection events
      #
      def subscribeCollection(room, collection, nodes=nil)
        begin
          instance = @roomInstance.gsub(/#room#/, room)
        rescue
          instance = @roomInstance
        end
        params="collection=#{collection}"
        if !nodes.nil?
          nodes = nodes.to_a
          params << nodes.unshift("").join("&node=") if nodes.length > 0
        end
        data = "instance=#{instance}&action=subscribe&#{params}&#{@authToken}"
        res = RTC::http_post("#{@baseURL}app/rtc", data, @authHeaders)
        puts res if RTC::DEBUG

        response = REXML::Document.new(res).root
        RTC::check_status response
      end

      #
      # Unsubscribe to collection events
      #
      def unsubscribeCollection(room, collection, nodes=nil)
        begin
          instance = @roomInstance.gsub(/#room#/, room)
        rescue
          instance = @roomInstance
        end
        params="collection=#{collection}"
        if !nodes.nil?
          nodes = nodes.to_a
          params << nodes.unshift("").join("&node=") if nodes.length > 0
        end
        data = "instance=#{instance}&action=unsubscribe&#{params}&#{@authToken}"
        res = RTC::http_post("#{@baseURL}app/rtc", data, @authHeaders)
        puts res if RTC::DEBUG

        response = REXML::Document.new(res).root
        RTC::check_status response
      end

      #
      # Publish an item
      #
      def publishItem(room, collection, node, item, overwrite = false)
        begin
          instance = @roomInstance.gsub(/#room#/, room)
        rescue
          instance = @roomInstance
        end

        headers = { "Content-Type" => "text/xml" }
      	headers.merge! @authHeaders

      	params = "instance=#{instance}&action=publish&collection=#{collection}&node=#{node}"
      	params << "&overwrite=true" if overwrite
      	params << "&#{@authToken}"
      	data = """
      	  <request>
          #{RTC::to_xml(item, "item")}
          </request>
        """
        res = RTC::http_post("#{@baseURL}app/rtc?#{params}", data, headers)
        puts res if RTC::DEBUG

        response = REXML::Document.new(res).root
        RTC::check_status response
      end

      #
      # Retract an item
      #
      def retractItem(room, collection, node, item)
        begin
          instance = @roomInstance.gsub(/#room#/, room)
        rescue
          instance = @roomInstance
        end

        data = "instance=#{instance}&collection=#{collection}&node=#{node}&item=#{item}&#{@authToken}"
        res = RTC::http_post("#{@baseURL}app/rtc", data, @authHeaders)
        puts res if RTC::DEBUG

        response = REXML::Document.new(res).root
        RTC::check_status response
      end

      #
      # Create a node
      #
      def createNode(room, collection, node, configuration=nil)
        begin
          instance = @roomInstance.gsub(/#room#/, room)
        rescue
          instance = @roomInstance
        end

        params = "instance=#{instance}&action=configure&collection=#{collection}&node=#{node}&#{@authToken}"

        if configuration
          headers = { "Content-Type" => "text/xml" }
          headers.merge! @authHeaders

      	  data = """
      	    <request>
            #{RTC::to_xml(configuration, "configuration")}
            </request>
          """
      	  res = RTC::http_post("#{@baseURL}app/rtc?#{params}", data, headers)
        else
          res = RTC::http_post("#{@baseURL}app/rtc", params, @authHeaders)
        end

        puts res if RTC::DEBUG

        response = REXML::Document.new(res).root
        RTC::check_status response
      end

      #
      # Remove a node or collection
      #
      def removeNode(room, collection, node=nil)
        begin
          instance = @roomInstance.gsub(/#room#/, room)
        rescue
          instance = @roomInstance
        end

        data = "instance=#{instance}&action=remove&collection=#{collection}&node=#{node}&#{@authToken}"

      	res = RTC::http_post("#{@baseURL}app/rtc", data, @authHeaders)
      	puts res if RTC::DEBUG

        response = REXML::Document.new(res).root
        RTC::check_status response
      end

      #
      # Configure a node
      #
      def setNodeConfiguration(room, collection, node, configuration)
        begin
          instance = @roomInstance.gsub(/#room#/, room)
        rescue
          instance = @roomInstance
        end

        headers = { "Content-Type" => "text/xml" }
        headers.merge! @authHeaders

        params = "instance=#{instance}&action=configure&collection=#{collection}&node=#{node}&#{@authToken}"

      	data = """
      	  <request>
                #{RTC::to_xml(configuration, "configuration")}
                </request>
              """
      	res = RTC::http_post("#{@baseURL}app/rtc?#{params}", data, headers)
      	puts res if RTC::DEBUG

        response = REXML::Document.new(res).root
        RTC::check_status response
      end

      #
      # Set user role
      #
      def setUserRole(room, user, role, collection=nil, node=nil)
        begin
          instance = @roomInstance.gsub(/#room#/, room)
        rescue
          instance = @roomInstance
        end

        data = "action=setrole&instance=#{instance}&user=#{user}&role=#{role.to_i}"
      	data << "&collection=#{collection}" if collection
      	data << "&node=#{node}" if node
      	data << "&#{@authToken}"
        res = RTC::http_post("#{@baseURL}app/rtc", data, @authHeaders)
      	puts res if RTC::DEBUG

        response = REXML::Document.new(res).root
        RTC::check_status response
      end

      #
      # Return information about the account if it is active.
      #
      def getAccountInfo()
        acctid = @roomInstance.split("/")[0]
        data = RTC::http_get("#{@baseURL}app/account?account=#{acctid}&#{@authToken}", @authHeaders)
      	puts data if DEBUG

        response = REXML::Document.new(data).root
      	RTC::check_status response

      	info = response.elements['account-info']
      	ainfo = AccountInfo.new
      	ainfo.userCount     = info.elements['user-count'].text.to_i
      	ainfo.peakUserCount = info.elements['peak-user-count'].text.to_i
      	ainfo.bytesUp       = info.elements['total-bytes-up'].text.to_i
      	ainfo.bytesDown     = info.elements['total-bytes-down'].text.to_i
      	ainfo.messages      = info.elements['total-messages'].text.to_i
      	ainfo.userTime      = RTC::parseElapsed(info.elements['total-time'].text)
      	ainfo.dateCreated   = RTC::parseDateTime(info.elements['date-created'].text)
      	ainfo.dateExpired   = RTC::parseDateTime(info.elements['date-expired'].text)
      	activeInstances = info.elements['active-FMS-instances'].text
      	ainfo.activeRooms = activeInstances[1,activeInstances.length-2].split(",").map { |v| v.match(/.*\/(.*)/)[1] }
      	return ainfo
      end

      #
      # Return information about the room or room instance if it is active.
      #
      def getRoomInfo(room)
        if room.include? '/'
          instance = room
        else
          instance = @roomInstance.gsub(/#room#/, room)
        end
        data = RTC::http_get("#{@baseURL}app/account?instance=#{instance}&#{@authToken}", @authHeaders)
        puts data if DEBUG

        response = REXML::Document.new(data).root
      	RTC::check_status response

      	info = response.elements['meeting-info']
      	rinfo = RoomInfo.new
      	rinfo.isConnected  = info.elements['is-connected'].text == 'true'
      	rinfo.userCount    = info.elements['user-count'].text.to_i
      	rinfo.bytesUp      = info.elements['total-bytes-up'].text.to_i
      	rinfo.bytesDown    = info.elements['total-bytes-down'].text.to_i
      	rinfo.messages     = info.elements['total-messages'].text.to_i
      	rinfo.peakUsers    = info.elements['peak-users'].text.to_i
      	rinfo.dateCreated  = RTC::parseDateTime(info.elements['date-created'].text)
      	rinfo.dateStarted  = RTC::parseDateTime(info.elements['date-started'].text)
      	rinfo.dateEnded    = RTC::parseDateTime(info.elements['date-ended'].text)
      	rinfo.dateExpired  = RTC::parseDateTime(info.elements['date-expired'].text)
      	return rinfo
      end

    #:stopdoc:

    protected
      def do_initialize
        return true if @contentPath

      	uri = URI.parse(@url)
        data = RTC::http_get("#{@url}?mode=xml&accountonly=true&#{@authToken}", @authHeaders)

        begin
      	  response = REXML::Document.new(data).root
        rescue
          raise RTC::Error, "invalid-account"
        end
        
      	case response.local_name
      	  when 'meeting-info'
      	    @baseURL = response.elements['baseURL'].attributes['href']
      	    @url = URI.join(@baseURL, uri.path).to_s
      	    @contentPath = response.elements['accountPath'].attributes['href']
            if (response.elements['room'])
      	      @roomInstance = response.elements['room'].attributes['instance']
            end
            if DEBUG
              puts "url:#{url}"
              puts "contentURL:#{contentURL}"
              puts "roomInstance:#{@roomInstance}"
            end
      	    return true

      	  when 'result'
       	    if response.attributes['code'] == "unauthorized"
  	        authURL = response.elements['authentication'].attributes['href']

  	        if response.elements['baseURL']
  	          @baseURL = response.elements['baseURL'].attributes['href']
  	          @url = URI.join(@baseURL, uri.path).to_s

              authURL = URI.join(@baseURL, authURL).to_s if authURL[0].chr == '/'
              if DEBUG
                puts "baseURL:#{@baseURL}"
                puts "url:#{@url}"
                puts "authURL:#{authURL}"
              end
            end

            @authenticator = Authenticator.new(authURL)
  	        return false
    	    end
        end

        raise RTC::Error, data
      end

      #:startdoc:
  end

  #:stopdoc:
  protected

    #
    # Get data and follow redirects.
    #
    def RTC.http_get(url, headers = nil)
      while true
      	puts "http_get #{url}" if DEBUG
      	puts "  #{headers.inspect}" if DEBUG && headers
        uri = (url.kind_of? URI) ? url : URI.parse(url)
      	http = Net::HTTP.new(uri.host, uri.port)
        if uri.scheme == "https"
          http.use_ssl = true
          http.verify_mode = OpenSSL::SSL::VERIFY_NONE
        end

        path = uri.path
        path << "?#{uri.query}" if uri.query

      	http.start {
      	  resp = http.get(path, headers)
      	  puts "Host: #{resp['X-Acorn-Hostname']}" if DEBUG && resp['X-Acorn-Hostname']

      	  case resp
      	     when Net::HTTPRedirection then
      	       url = resp['location']

      	     when Net::HTTPSuccess then
      	       return resp.body

      	     else
      	       raise RTC::Error, resp.code
      	  end
      	}
      end
    end

    def RTC.http_post(url, data, headers = nil)
      puts "http_post #{url} #{data}" if DEBUG
      puts "  #{headers.inspect}" if DEBUG && headers

      uri = (url.kind_of? URI) ? url : URI.parse(url)
      http = Net::HTTP.new(uri.host, uri.port)
      if uri.scheme == "https"
      	http.use_ssl = true
      	http.verify_mode = OpenSSL::SSL::VERIFY_NONE
      end

      path = uri.path
      path << "?#{uri.query}" if uri.query

      http.start {
      	resp = http.post(path, data, headers)
      	puts "Host: #{resp['X-Acorn-Hostname']}" if DEBUG && resp['X-Acorn-Hostname']

      	if resp.kind_of? Net::HTTPSuccess
      	  return resp.body
      	else
      	  raise RTC::Error, resp.code
      	end
      }
  end

  def RTC.check_status(response)
    status = response.elements['status']
    code = status.attributes['code']
    subcode = status.attributes['subcode']
    return code if code == "ok"
    raise RTC::Error, subcode.nil? ? code : subcode
  end

  def RTC.url_escape(url)
    url.gsub(/([^ a-zA-Z0-9_.-]+)/n) do
      '%' + $1.unpack('H2' * $1.size).join('%').upcase
    end.tr(' ', '+')
  end

  def RTC.to_xml(hash, root=nil)
    result = ""

    if root
      if root == 'item'
        id = hash.has_key?('itemID') ? hash['itemID'] : 'item'
        result << "<#{root} id=\"#{id}\">"
      else
        result << "<#{root}>"
      end
    end

    hash.each { |name,value|
      if root == 'configuration'
        result << "<field var=\"#{name}\">"
      else
        result << "<property name=\"#{name}\">"
      end

      type = if value.is_a? Fixnum
    	  "int"
    	elsif value.is_a? Bignum
    	  "long"
    	elsif value.is_a? Float
    	  "double"
    	elsif value.is_a? String
    	  "string"
    	elsif value.is_a?(TrueClass) || value.is_a?(FalseClass)
    	  "boolean"
    	elsif value.is_a? Hash
    	  "object"
    	elsif value.is_a? Array
    	  "array"
    	else
        "undefined:#{value.class}"
      end

      result << "<value type=\"#{type}\">"

      if value.is_a?(Hash) #|| value.is_a?(Array)
        result << RTC::to_xml(value)
      elsif value.is_a? String
        value = value.dup if value.frozen?
        result << REXML::Text.new(value, true).to_s
      else
        result << value.to_s
      end

      result << "</value>"

      if root == 'configuration'
        result << "</field>"
      else
        result << "</property>"
      end
    }

    result << "</#{root}>" if root
    return result
  end

  def RTC.from_xml(xml)
    hash = {}

    xml.each { |e|
      if e.local_name == 'item'
        name = e.attributes['id']
        value = RTC::from_xml e
      else
        if e.local_name == 'field'
          name = e.attributes['var']	# field
        else
          name = e.attributes['name']	# property
        end

        v = e.elements['value']
        if v
          type = v.attributes['type']
          value = v.text

      	  case type
      	    when "boolean"
      	      value = (value == "true")

      	    when "int", "long"
      	      value = value.to_i

      	    when "double"
      	      value = value.to_f

      	    when "xml"
      	      value = REXML::Document.new(value).root

      	    when "object"
      	      value = RTC::from_xml v

      	    when "array"
      	      value = RTC::from_xml v
      	  end
        else
          value = nil
        end
      end

      hash[name] = value
    }

    return hash
  end

  #
  # parse a date/time
  # returns a DateTime
  #
  def RTC.parseDateTime(s)
    return nil if s.nil? 
    return nil if s == 'NULL'
    #return DateTime.strptime(s, fmt='%a %b %d %H:%M:%S %Z %Y')
    return DateTime.parse(s)
  end

  #
  # parse elapsed time (days hh:mm:ss.xxx)
  # returns number of seconds
  #
  def RTC.parseElapsed(s)
    return nil if s.nil? 
    return nil if s == 'NULL'
    empty,d,h,m,s = s.split(/\s*(\d+) (\d\d):(\d\d):(\d\d).*/)
    return (d.to_i*24 + h.to_i)*3600 + m.to_i*60 + s.to_i
  end

  #:startdoc:

end # module RTC

if __FILE__ == $0

  def usage
    puts "usage: #{$0} [--debug] [--host=url] account user password command parameters..."
    puts ""
    puts "where <command> is:"
    puts "    --list"
    puts "    --create room [template]"
    puts "    --create-autodelete room [template]"
    puts "    --delete room"
    puts "    --delete-template template"
    puts "    --ext-auth secret room username userid role"
    puts "    --invalidate room"
    puts ""
    puts "    --get-node-configuration room collection node"
    puts "    --fetch-items room collection node"
    puts "    --register-hook endpoint [token]"
    puts "    --unregister-hook"
    puts "    --hook-info"
    puts "    --subscribe-collection room collection"
    puts "    --unsubscribe-collection room collection"
    puts "    --create-node room collection [node]"
    puts "    --remove-node room collection [node]"
    puts "    --set-user-role room userID role [collection [node]]"
    puts "    --publish-item room collection node itemID body"
    puts "    --retract-item room collection node itemID"
    puts ""    
    puts "    --register-repository endpoint [token]"
    puts "    --unregister-repository"
    puts "    --repository-info"
    puts "    --start-recording room [[archiveId] [guestsAllowed]]"
    puts "    --stop-recording room"
    puts "    --delete-archive archive"
    puts "    --move-archive archive [template]"
    exit 1
  end

  def getRole(r)
    case r.downcase
      when "none"
        return RTC::UserRole::NONE
      when "lobby"
        return RTC::UserRole::LOBBY
      when "viewer"
        return RTC::UserRole::VIEWER
      when "publisher"
        return RTC::UserRole::PUBLISHER
      when "owner"
        return RTC::UserRole::OWNER
      else
        return r.to_i
    end
  end

  host = "https://cloud.ics.influxis.com"

  while ARGV.length > 0
    case ARGV[0]
      when /--host=(.*)/
	host = Regexp.last_match[1]

      when "--debug"
        RTC::DEBUG = true

      else
        break
    end

    ARGV.shift
  end

  if ARGV.length < 3
    usage
  end

  accountName = ARGV.shift
  username = ARGV.shift
  password = ARGV.shift

  accountURL = "#{host}/#{accountName}"
  puts "account: #{accountURL}" if RTC::DEBUG

  begin
    am = RTC::AccountManager.new(accountURL)
    am.login(username, password)

    if ARGV.length == 0
      ARGV[0] = "--list"
    end

    while ARGV.length > 0
      case ARGV.shift

      when "--list"
      	puts "==== template list for #{accountName} ===="
      	am.listTemplates().each { 
      	  |t| puts "#{t.name}:#{t.created.asctime}"
      	}

      	puts "==== room list for #{accountName} ===="
      	am.listRooms().each {
          |r| puts "#{r.name}:#{r.templatename}:#{r.created ? r.created.asctime : ''}"
      	}
        puts "==== archive list for #{accountName} ===="
        am.listArchives().each {
          |r| puts "#{r.name}:#{r.templatename}:#{r.created ? r.created.asctime : ''}"
        }
      
      when "--create"
      	#
      	# Create a room.
      	#
      	room = ARGV.shift
      	template = if ARGV.length > 0; then ARGV.shift else nil end
      	puts am.createRoom(room, template)

      when "--delete"
      	#
      	# Delete a room.
      	#
      	room = ARGV.shift
      	puts am.deleteRoom(room)

      when "--create-autodelete" then
        #
        # Create a room and delete it after it runs
        #
        room = ARGV.shift
        template = if ARGV.length > 0; then ARGV.shift else nil end
        puts am.createRoom(room, template, true)

      when "--delete-template"
      	#
      	# Delete a template.
      	#
      	template = ARGV.shift
      	puts am.deleteTemplate(template)

      when "--delete-archive" then
        #
        # Delete an archive.
        #
        archive = ARGV.shift
        puts am.deleteArchive(archive)

      when "--ext-auth"
      	#
      	# Get a session and create external authentication tokens.
      	#
      	secret = ARGV.shift
      	room = ARGV.shift
      	user = ARGV.shift
      	userId = ARGV.shift

      	if ARGV.length > 0
      	  role = getRole(ARGV.shift)
      	else
      	  role = RTC::UserRole::LOBBY
      	end
      	sess = am.getSession(room)
      	puts sess.getAuthenticationToken(secret, user, userId, role)
      	puts "userID: #{sess.getUserID(userId)}"

      when "--invalidate"
      	#
      	# Invalidate a session.
      	#
      	room = ARGV.shift
      	sess = am.getSession(room)
      	puts am.invalidateSession(sess)

      when "--info"
      	#
      	# Get account or room session information.
      	#
      	if ARGV.length == 0
      	  puts am.getAccountInfo().inspect

      	else
      	  room = ARGV.shift
      	  puts am.getRoomInfo(room).inspect
      	end

      when "--get-node-configuration"
      	room = ARGV.shift
        collection = ARGV.shift
        node = ARGV.shift
      	puts am.getNodeConfiguration(room, collection, node).inspect

      when "--fetch-items"
        room = ARGV.shift
        collection = ARGV.shift
        node = ARGV.shift
      	items = ARGV
        puts am.fetchItems(room, collection, node, items).inspect
      	ARGV.clear
        
      when "--subscribe-collection"
      	room = ARGV.shift
        collection = ARGV.shift
        nodes = ARGV
        puts am.subscribeCollection(room, collection, nodes)
        ARGV.clear

      when "--unsubscribe-collection"
        room = ARGV.shift
        collection = ARGV.shift
        nodes = ARGV
        puts am.unsubscribeCollection(room, collection, nodes)
        ARGV.clear

      when "--register-hook"
        endpoint = ARGV.length > 0 ? ARGV.shift : nil
        token = ARGV.length > 0 ? ARGV.shift : nil
        puts am.registerHook(endpoint, token)
        ARGV.clear

      when "--unregister-hook"
        puts am.registerHook()

      when "--hook-info"
        puts am.getHookInfo().inspect

      when "--register-repository" then
        endpoint = ARGV.length > 0 ? ARGV.shift : nil
        token = ARGV.length > 0 ? ARGV.shift : nil
        puts am.registerRepository(endpoint, token)
        ARGV.clear

      when "--unregister-repository" then
        puts am.registerRepository()

      when "--repository-info" then
        puts am.getRepositoryInfo().inspect
  
      when "--start-recording" then
        room = ARGV.shift
        archiveId = ARGV.length > 0 ? ARGV.shift : '__defaultArchive__'
        guestsAllowed = ARGV.length > 0 ? ARGV.shift : true
        puts am.startRecording(room, archiveId, guestsAllowed)
  
      when "--stop-recording" then
        room = ARGV.shift
        puts am.stopRecording(room)
  
      when "--move-archive" then
        archive = ARGV.length > 0 ? ARGV.shift : nil
        template = ARGV.length > 0 ? ARGV.shift : nil
        puts am.moveArchive(archive, template)
        ARGV.clear
  
      when "--create-node"
        room = ARGV.shift
        collectionName = ARGV.shift
        nodeName = ARGV.length > 0 ? ARGV.shift : nil
        puts am.createNode(room, collectionName, nodeName)

      when "--remove-node"
      	room = ARGV.shift
      	collectionName = ARGV.shift
      	nodeName = ARGV.length > 0 ? ARGV.shift : nil
      	puts am.removeNode(room, collectionName, nodeName)

      when "--set-user-role"
      	room = ARGV.shift
      	userID = ARGV.shift
      	role = getRole(ARGV.shift)
      	collectionName = ARGV.length > 0 ? ARGV.shift : nil
      	nodeName = ARGV.length > 0 ? ARGV.shift : nil
      	puts am.setUserRole(room, userID, role, collectionName, nodeName)

      when "--publish-item"
      	room = ARGV.shift
      	collectionName = ARGV.shift
      	nodeName = ARGV.shift
      	itemID = ARGV.shift
      	body = ARGV.shift

      	itemVO = { "itemID" => itemID, "body" => body }
      	puts am.publishItem(room, collectionName, nodeName, itemVO)

      when "--retract-item"
      	room = ARGV.shift
      	collectionName = ARGV.shift
      	nodeName = ARGV.shift
      	itemID = ARGV.shift
      	puts am.retractItem(room, collectionName, nodeName, itemID)

      else
      	usage()
      end
    end

  rescue RTC::Error => e
    puts "Error: #{e.message}"
  end
end
