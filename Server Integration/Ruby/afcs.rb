#!env ruby
#
# = Synopsis
#
# This library allows you to connect to the Adobe Flash Collaboration Service and
# manage an account, including listing rooms and templates, creating new rooms, and
# deleting rooms and templates.
#
# == Examples
#
#   require 'afcs'
#
#   # 
#   # Create a new account manager object using your account URL. This URL is displayed
#   # in the Developer Portal when you log in.
#   #  
#   am = AFCS::AccountManager.new("http://connectnow.acrobat.com/<YOUR DEVELOPER ACCOUNT NAME>")
#   
#   # 
#   # Use the login method to log in with your developer account's username and password.
#   # 
#   am.login(accountowner, accountpassword)
#
#   #
#   # Use the keepalice method to keep the authentication token alive
#   #
#   am.keepalive(accountowner, accountpassword)
#
#   # 
#   # Use the provided methods to list, create, and delete rooms and templates on-the-fly.
#   # 
#   rooms = am.listRooms()
#   templates = am.listTemplates()
#   am.createRoom("newRoom")
#   am.deleteRoom("newRoom")
#   am.createRoom("newRoom", "fromTemplate")
#   am.deleteTemplate("fromTemplate")
#
#   #
#   # External authentication
#   #
#   session = am.getSession("room1")
#   secret = "account-shared-secret"
#   puts session.getAuthenticationToken(secret, "raff", "x-raff", 100)
#   puts session.getAuthenticationToken(secret, "bob", "x-bob", 50)
#   puts session.getAuthenticationToken(secret, "bill", "x-bill", 5)
#
#   am.invalidateSession(session)
#
#   #
#   # Account and room info
#   #
#   puts am.getAccountInfo()
#   puts am.getRoomInfo("room").inspect
#   puts am.getRoomInfo("accountident/room").inspect
#
#   #
#   # Collection and node info
#   #
#   puts am.getNodeConfiguration("room", "CollectionName", "NodeName").inspect
#   puts am.fetchItems("room", "CollectionName", "NodeName").inspect
#   puts am.publishItem("room", "CollectionName", "NodeName", item)
#
#   #
#   # Events handling
#   #
#   puts am.registerHook("http://hook.endpoint.url", "securityToken")
#   puts am.subscribeCollection("room", "CollectionName")
#
# = Revision
#   $Revision: #37 $ - $Date: 2010/04/13 $
#
# = Author
#
#   Raffaele Sena
#
# = Copyright
#
#   Copyright 2007 - 2009 Adobe Systems Incorporated and its licensors.
#   All rights reserved.
#
require "base64"
require "digest/md5"
require "date"
require "net/https"
require "rexml/document"
require "openssl"

module AFCS

  DEBUG = false
  VERSION = "$Revision: #37 $ - $Date: 2010/04/13 $"

  #
  # An error thrown or generated by the AFCS API.
  #
  class Error < StandardError
  end

  # 
  # Constants for common user roles. These are mirrored in the Room Console as well.
  # 
  class UserRole
    NONE      = 0
    LOBBY     = 5
    VIEWER    = 10
    PUBLISHER = 50
    OWNER     = 100
  end
  
  #
  # Constants for node configuration
  #
  class NodeConfiguration
    STORAGE_SCHEME_SINGLE_ITEM = 0
    STORAGE_SCHEME_QUEUE       = 1
    STORAGE_SCHEME_MANUAL      = 2
  end

  #####################################################
  #
  # A class that generates AFCS authentication tokens.
  #
  class Authenticator
    def initialize(url)
      @authURI = URI.parse(url)
    end

    #
    # Get an AFCS authentication token give login and password.
    #
    def login(user, password, authHeaders)
      headers = { "Content-Type" => "text/xml" };
      data = """
        <request>
          <username>#{user}</username>
          <password>#{password}</password>
        </request>
      """
      
      resp = AFCS::http_post(@authURI, data, headers)

      response = REXML::Document.new(resp).root
      if response.attributes['status'] == "ok"
        authToken = response.elements['authtoken']
      	if authToken.attributes['type'] == "COOKIE"
      	  authHeaders['Cookie'] = authToken.text
      	  token = nil
        else
          auth = authToken.text
          gak = Base64.encode64(auth).gsub("\n","")
      	  token = "gak=#{gak}"
        end

      	puts "token: #{token}, auth:#{auth}, headers:#{authHeaders.inspect}" if AFCS::DEBUG
      	return token
      else
        raise AFCS::Error, resp
      end
    end

    #
    # Get a guest authentication token.
    #
    def self.guestLogin(user)
      guk = Base64.encode64("g:#{user}:").gsub("\n","")
      return "guk=#{guk}"
    end
  end

  #####################################################
  #
  # A class that deals with meeting sessions and
  # external authentication.
  #
  class Session
    #
    # Get an external authentication token.
    #
    def getAuthenticationToken(accountSecret, name, id, role)
      token = "x:#{name}::#{@account}:#{id}:#{@room}:#{role.to_i}"
      signed = "#{token}:#{sign(accountSecret, token)}"

      # unencoded
      #return "ext=#{signed}"

      # encoded
      enc = Base64.encode64(signed).gsub("\n","")
      return "exx=#{enc}"
    end

    #
    # Get the userId that the server will generate for this user
    #
    def getUserID(id)
      return "EXT-#{@account}-#{id}".upcase
    end
    
    #:stopdoc:

    def initialize(instance, account, room)
      begin
        @instance = instance.gsub(/#room#/, room)
      rescue
        @instance = instance
      end
      
      @account = account
      @room = room
      @digest = OpenSSL::Digest::Digest.new('SHA1')
    end

    def getSecret(baseURL, authToken, authHeaders)
      data = AFCS::http_get("#{baseURL}app/session?instance=#{@instance}&#{authToken}", authHeaders)
      puts data if AFCS::DEBUG

      response = REXML::Document.new(data).root
      @secret = response.elements['session-secret'].text
    end

    def invalidate(baseURL, authToken, authHeaders)
      data = "action=delete&instance=#{@instance}&#{authToken}"
      res = AFCS::http_post("#{baseURL}app/session", data, authHeaders)
      puts res if AFCS::DEBUG

      @instance = nil
      @account = nil
      @room = nil
      @digest = nil
      @secret = nil

      response = REXML::Document.new(res).root
      AFCS::check_status response
    end

    def marshal_dump
      [@instance, @account, @room, @secret]
    end

    def marshal_load(data)
      @instance = data.shift
      @account  = data.shift
      @room     = data.shift
      @secret   = data.shift
      @digest = OpenSSL::Digest::Digest.new('SHA1')
    end

    protected
      def sign(acctSecret, data)
        return OpenSSL::HMAC.hexdigest(@digest, 
          "#{acctSecret}:#{@secret}", data)
      end

    #:startdoc:#:
  end

  #####################################################
  #
  # A class that contains room or template item information.
  #
  class Item
    protected
      def initialize(name, desc, created)
        @name = name
        @desc = desc
        @created = DateTime.parse(created)
      end

    public
      attr_reader :name, :desc, :created
      alias_method :templatename, :desc
  end
 
  #####################################################
  #
  # A class that contains room session info
  #
  class RoomInfo
    attr_accessor :isConnected, :userCount, :bytesUp, :bytesDown, :messages, :peakUsers, 
	:dateCreated, :dateStarted, :dateEnded, :dateExpired
  end

  #####################################################
  #
  # A class that contains account session info
  #
  class AccountInfo
    attr_accessor :userCount, :peakUserCount, :bytesUp, :bytesDown, :messages,
	:userTime, :dateCreated, :dateExpired, :activeRooms
  end

  #####################################################
  #
  # A class that deals with account information and provisioning.
  #
  class AccountManager
    public
      ROOM_ITEMS     = "meetings"
      TEMPLATE_ITEMS = "templates"

      def url
        @url
      end

      def contentURL
        "#{@baseURL}app/content#{@contentPath}"
      end

      def initialize(url)
        @url = url
        @authToken = nil
        @authHeaders = {}
        @authenticator = nil
        @baseURL = nil
        @contentPath = nil
        @roomInstance = nil

        puts VERSION if DEBUG

        do_initialize
      end

      #
      # Login and connect to the account
      #
      def login(user, password = nil)
        if password != nil
          @authToken = @authenticator.login(user, password, @authHeaders)
        else
          @authToken = Authenticator.guestLogin(user)
        end

        do_initialize
      end

      #
      # Keep the authentication token alive by accessing the account.
      #
      # If the requerst fails with an authentication error
      # and credentials are provided, this method will authenticated again
      # 
      def keepalive(user = nil, password = nil)
        @contentPath = nil
        return true if do_initialize
        return login(user, password) if user
        return false
      end

      #
      # Create a room. If no template is specified, use the default, empty template.
      #
      def createRoom(room, template = nil)
        template = "default" if !template
        data = "mode=xml&room=#{room}&template=#{template}&#{@authToken}"
        res = AFCS::http_post(@url, data, @authHeaders)
	puts res if AFCS::DEBUG

        response = REXML::Document.new(res).root
	if response.local_name != "meeting-info"
          raise AFCS::Error, res
        else
          return "ok"
        end
      end

      #
      # List rooms or templates.
      #
      def list(type = ROOM_ITEMS)
        case type
          when ROOM_ITEMS:
          when TEMPLATE_ITEMS:
          else
            raise AFCS::Error, "invalid-type"
        end

        data = AFCS::http_get("#{contentURL}/#{type}/?#{@authToken}", @authHeaders)

        items = Array.new

        response = REXML::Document.new(data).root
        response.elements.each("children/node") {
          |n|

          name = n.elements["name"].text
          desc = n.elements["properties/property[@name = 'cr:description']"]
          desc = desc.elements["value"].text if desc
          created = n.elements["properties/property[@name = 'jcr:created']"]
          created = created.elements["value"].text if created

          items.push(Item.new(name, desc, created))
        }

	      return items
      end

      #
      # Delete a room or a template.
      #
      def delete(item, type = ROOM_ITEMS, list = false)
        case type
          when ROOM_ITEMS:
          when TEMPLATE_ITEMS:
          else
            raise AFCS::Error, "invalid-type"
        end

        durl = "#{contentURL}/#{type}/#{item}"

	if list
	  limitCount = ""
	else
	  limitCount = "&count=0"
	end

        data = "action=delete&response=inline#{limitCount}&#{@authToken}"
        res = AFCS::http_post(durl, data, @authHeaders)
	puts res if AFCS::DEBUG

        response = REXML::Document.new(res).root
        return response
      end

      #
      # List rooms.
      #
      def listRooms()
        return list(ROOM_ITEMS)
      end

      #
      # List templates.
      #
      def listTemplates()
        return list(TEMPLATE_ITEMS)
      end

      #
      # Delete a room.
      #
      def deleteRoom(r, list = false)
        raise AFCS::Error, "parameter-required" if r.nil?
        return delete(r.downcase, ROOM_ITEMS, list)
      end

      #
      # Delete a template.
      #
      def deleteTemplate(t, list = false)
        raise AFCS::Error, "parameter-required" if t.nil?
        return delete(t, TEMPLATE_ITEMS, list)
      end

      #
      # Return a room session for external authentication.
      #
      def getSession(room)
        session = Session.new(@roomInstance, url.split("/")[-1], room)
      	session.getSecret(@baseURL, @authToken, @authHeaders)
      	return session
      end

      #
      # Invalidate the room session.
      #
      def invalidateSession(session)
        session.invalidate(@baseURL, @authToken, @authHeaders)
      end

      #
      # Return the node configuration
      #
      def getNodeConfiguration(room, coll, node)
        begin
          instance = @roomInstance.gsub(/#room#/, room)
        rescue
          instance = @roomInstance
        end
	path = "/#{coll}/nodes/#{node}/configuration"
        data = AFCS::http_get("#{@baseURL}app/rtc?instance=#{instance}&path=#{path}&#{@authToken}", @authHeaders)
	puts data if AFCS::DEBUG

        response = REXML::Document.new(data).root
	AFCS::check_status response
	
	coll = response.elements["collections/node"]
	raise AFCS::Error, "invalid-collection" if coll.nil?
	node = coll.elements["collection/nodes/node"]
	raise AFCS::Error, "invalid-node" if node.nil?

        return AFCS::from_xml(node.elements["collection/configuration"])
      end

      #
      # Return the AFCS nodes @ path.
      #
      def fetchItems(room, coll, node, items=nil)
        begin
          instance = @roomInstance.gsub(/#room#/, room)
        rescue
          instance = @roomInstance
        end
        
        params = "instance=#{instance}&collection=#{coll}&node=#{node}"
        if !items.nil?
          items = items.to_a
          params << items.unshift("").join("&item=") if items.length > 0
        end   
        params << "&#{@authToken}"
        
        data = AFCS::http_get("#{@baseURL}app/rtc?#{params}", @authHeaders)
	puts data if AFCS::DEBUG 

        response = REXML::Document.new(data).root
	AFCS::check_status response

	coll = response.elements["collections/node"]
	raise AFCS::Error, "invalid-collection" if coll.nil?
	node = coll.elements["collection/nodes/node"]
	raise AFCS::Error, "invalid-node" if node.nil?

        return AFCS::from_xml(node.elements["collection/items"])
      end
      
      #
      # Register endpoint URL for webhooks
      #
      def registerHook(endpoint=nil, token=nil)
        acctid = @roomInstance.split("/")[0]
        data = "account=#{acctid}&action=registerhook"
        data << "&endpoint=#{AFCS.url_escape(endpoint)}" if endpoint
        data << "&token=#{AFCS.url_escape(token)}" if token
        data << "&#{@authToken}"
        res = AFCS::http_post("#{@baseURL}app/rtc", data, @authHeaders)
	puts res if AFCS::DEBUG

        response = REXML::Document.new(res).root
        AFCS::check_status response
      end
      
      #
      # Unregister endpoint URL for webhooks
      #
      def unregisterHook
	return registerHook()
      end
        
      #
      # Return the webhook information
      #
      def getHookInfo()
        acctid = @roomInstance.split("/")[0]
        data = AFCS::http_get("#{@baseURL}app/rtc?action=hookinfo&account=#{acctid}&#{@authToken}", @authHeaders)
	puts data if AFCS::DEBUG

        response = REXML::Document.new(data).root
	AFCS::check_status response

	return {
	  'endpoint' => response.elements["param[@name='registerHookEndpoint']"].text,
	  'token' => response.elements["param[@name='registerHookToken']"].text
	}
      end

      #
      # Subscribe to collection events
      #
      def subscribeCollection(room, collection, nodes=nil)
        begin
          instance = @roomInstance.gsub(/#room#/, room)
        rescue
          instance = @roomInstance
        end
        params="collection=#{collection}"
        if !nodes.nil?
          nodes = nodes.to_a
          params << nodes.unshift("").join("&node=") if nodes.length > 0
        end
        data = "instance=#{instance}&action=subscribe&#{params}&#{@authToken}"
        res = AFCS::http_post("#{@baseURL}app/rtc", data, @authHeaders)
	puts res if AFCS::DEBUG

        response = REXML::Document.new(res).root
        AFCS::check_status response
      end

      #
      # Unsubscribe to collection events
      #
      def unsubscribeCollection(room, collection, nodes=nil)
        begin
          instance = @roomInstance.gsub(/#room#/, room)
        rescue
          instance = @roomInstance
        end
        params="collection=#{collection}"
        if !nodes.nil?
          nodes = nodes.to_a
          params << nodes.unshift("").join("&node=") if nodes.length > 0
        end
        data = "instance=#{instance}&action=unsubscribe&#{params}&#{@authToken}"
        res = AFCS::http_post("#{@baseURL}app/rtc", data, @authHeaders)
	puts res if AFCS::DEBUG

        response = REXML::Document.new(res).root
        AFCS::check_status response
      end

      #
      # Publish an item
      #
      def publishItem(room, collection, node, item, overwrite = false)
        begin
          instance = @roomInstance.gsub(/#room#/, room)
        rescue
          instance = @roomInstance
        end

        headers = { "Content-Type" => "text/xml" }
	headers.merge! @authHeaders

	params = "instance=#{instance}&action=publish&collection=#{collection}&node=#{node}"
	params << "&overwrite=true" if overwrite
	params << "&#{@authToken}"
	data = """
	  <request>
          #{AFCS::to_xml(item, "item")}
          </request>
        """
	res = AFCS::http_post("#{@baseURL}app/rtc?#{params}", data, headers)
	puts res if AFCS::DEBUG

        response = REXML::Document.new(res).root
        AFCS::check_status response
      end

      #
      # Retract an item
      #
      def retractItem(room, collection, node, item)
        begin
          instance = @roomInstance.gsub(/#room#/, room)
        rescue
          instance = @roomInstance
        end

        data = "instance=#{instance}&collection=#{collection}&node=#{node}&item=#{item}&#{@authToken}"
        res = AFCS::http_post("#{@baseURL}app/rtc", data, @authHeaders)
	puts res if AFCS::DEBUG

        response = REXML::Document.new(res).root
        AFCS::check_status response
      end

      #
      # Create a node
      #
      def createNode(room, collection, node, configuration=nil)
        begin
          instance = @roomInstance.gsub(/#room#/, room)
        rescue
          instance = @roomInstance
        end

        params = "instance=#{instance}&action=configure&collection=#{collection}&node=#{node}&#{@authToken}"

	if configuration
          headers = { "Content-Type" => "text/xml" }
	  headers.merge! @authHeaders

	  data = """
	    <request>
            #{AFCS::to_xml(configuration, "configuration")}
            </request>
          """
	  res = AFCS::http_post("#{@baseURL}app/rtc?#{params}", data, headers)
        else
	  res = AFCS::http_post("#{@baseURL}app/rtc", params, @authHeaders)
        end

	puts res if AFCS::DEBUG

        response = REXML::Document.new(res).root
        AFCS::check_status response
      end

      #
      # Remove a node or collection
      #
      def removeNode(room, collection, node=nil)
        begin
          instance = @roomInstance.gsub(/#room#/, room)
        rescue
          instance = @roomInstance
        end

        data = "instance=#{instance}&action=remove&collection=#{collection}&node=#{node}&#{@authToken}"

	res = AFCS::http_post("#{@baseURL}app/rtc", data, @authHeaders)
	puts res if AFCS::DEBUG

        response = REXML::Document.new(res).root
        AFCS::check_status response
      end

      #
      # Configure a node
      #
      def setNodeConfiguration(room, collection, node, configuration)
        begin
          instance = @roomInstance.gsub(/#room#/, room)
        rescue
          instance = @roomInstance
        end

        headers = { "Content-Type" => "text/xml" }
	headers.merge! @authHeaders

        params = "instance=#{instance}&action=configure&collection=#{collection}&node=#{node}&#{@authToken}"

	data = """
	  <request>
          #{AFCS::to_xml(configuration, "configuration")}
          </request>
        """
	res = AFCS::http_post("#{@baseURL}app/rtc?#{params}", data, headers)
	puts res if AFCS::DEBUG

        response = REXML::Document.new(res).root
        AFCS::check_status response
      end

      #
      # Set user role
      #
      def setUserRole(room, user, role, collection=nil, node=nil)
        begin
          instance = @roomInstance.gsub(/#room#/, room)
        rescue
          instance = @roomInstance
        end

        data = "action=setrole&instance=#{instance}&user=#{user}&role=#{role.to_i}"
	data << "&collection=#{collection}" if collection
	data << "&node=#{node}" if node
	data << "&#{@authToken}"
        res = AFCS::http_post("#{@baseURL}app/rtc", data, @authHeaders)
	puts res if AFCS::DEBUG

        response = REXML::Document.new(res).root
        AFCS::check_status response
      end

      #
      # Return information about the account if it is active.
      #
      def getAccountInfo()
        acctid = @roomInstance.split("/")[0]
        data = AFCS::http_get("#{@baseURL}app/account?account=#{acctid}&#{@authToken}", @authHeaders)
	puts data if DEBUG

        response = REXML::Document.new(data).root
	AFCS::check_status response

	info = response.elements['account-info']
	ainfo = AccountInfo.new
	ainfo.userCount     = info.elements['user-count'].text.to_i
	ainfo.peakUserCount = info.elements['peak-user-count'].text.to_i
	ainfo.bytesUp       = info.elements['total-bytes-up'].text.to_i
	ainfo.bytesDown     = info.elements['total-bytes-down'].text.to_i
	ainfo.messages      = info.elements['total-messages'].text.to_i
	ainfo.userTime      = AFCS::parseElapsed(info.elements['total-time'].text)
	ainfo.dateCreated   = AFCS::parseDateTime(info.elements['date-created'].text)
	ainfo.dateExpired   = AFCS::parseDateTime(info.elements['date-expired'].text)
	activeInstances = info.elements['active-FMS-instances'].text
	ainfo.activeRooms = activeInstances[1,activeInstances.length-2].split(",").map { |v| v.match(/.*\/(.*)/)[1] }
	return ainfo
      end

      #
      # Return information about the room or room instance if it is active.
      #
      def getRoomInfo(room)
        if room.include? '/'
          instance = room
        else
          instance = @roomInstance.gsub(/#room#/, room)
        end
        data = AFCS::http_get("#{@baseURL}app/account?instance=#{instance}&#{@authToken}", @authHeaders)
	puts data if DEBUG

        response = REXML::Document.new(data).root
	AFCS::check_status response

	info = response.elements['meeting-info']
	rinfo = RoomInfo.new
	rinfo.isConnected  = info.elements['is-connected'].text == 'true'
	rinfo.userCount    = info.elements['user-count'].text.to_i
	rinfo.bytesUp      = info.elements['total-bytes-up'].text.to_i
	rinfo.bytesDown    = info.elements['total-bytes-down'].text.to_i
	rinfo.messages     = info.elements['total-messages'].text.to_i
	rinfo.peakUsers    = info.elements['peak-users'].text.to_i
	rinfo.dateCreated  = AFCS::parseDateTime(info.elements['date-created'].text)
	rinfo.dateStarted  = AFCS::parseDateTime(info.elements['date-started'].text)
	rinfo.dateEnded    = AFCS::parseDateTime(info.elements['date-ended'].text)
	rinfo.dateExpired  = AFCS::parseDateTime(info.elements['date-expired'].text)
	return rinfo
      end

    #:stopdoc:

    protected
      def do_initialize
        return true if @contentPath

      	uri = URI.parse(@url)
        data = AFCS::http_get("#{@url}?mode=xml&accountonly=true&#{@authToken}", @authHeaders)

        begin
      	  response = REXML::Document.new(data).root
        rescue
          raise AFCS::Error, "invalid-account"
        end
        
      	case response.local_name
      	  when 'meeting-info' :
      	    @baseURL = response.elements['baseURL'].attributes['href']
      	    @url = URI.join(@baseURL, uri.path).to_s
      	    @contentPath = response.elements['accountPath'].attributes['href']
                  if (response.elements['room'])
      	      @roomInstance = response.elements['room'].attributes['instance']
                  end
                  if DEBUG
                    puts "url:#{url}"
                    puts "contentURL:#{contentURL}"
                    puts "roomInstance:#{@roomInstance}"
                  end
      	    return true

      	  when 'result' :
      	    if response.attributes['code'] == "unauthorized"
      	        authURL = response.elements['authentication'].attributes['href']

      	        if response.elements['baseURL']
      	          @baseURL = response.elements['baseURL'].attributes['href']
      	          @url = URI.join(@baseURL, uri.path).to_s

                        authURL = URI.join(@baseURL, authURL).to_s if authURL[0].chr == '/'
                        if DEBUG
                          puts "baseURL:#{@baseURL}"
                          puts "url:#{@url}"
                          puts "authURL:#{authURL}"
                        end
                      end
	       
                      @authenticator = Authenticator.new(authURL)
      	        return false
      	    end
        end

        raise AFCS::Error, data
      end

      #:startdoc:
  end

  #:stopdoc:
  protected

    #
    # Get data and follow redirects.
    #
    def AFCS.http_get(url, headers = nil)
      while true
      	puts "http_get #{url}" if DEBUG
      	puts "  #{headers.inspect}" if DEBUG && headers
        uri = (url.kind_of? URI) ? url : URI.parse(url)
      	http = Net::HTTP.new(uri.host, uri.port)
        if uri.scheme == "https"
          http.use_ssl = true
          http.verify_mode = OpenSSL::SSL::VERIFY_NONE
        end

        path = uri.path
        path << "?#{uri.query}" if uri.query

      	http.start {
      	  resp, body = http.get(path, headers)
      	  puts "Host: #{resp['X-Acorn-Hostname']}" if DEBUG && resp['X-Acorn-Hostname']

      	  case resp
      	     when Net::HTTPRedirection then
      	       url = resp['location']

      	     when Net::HTTPSuccess then
      	       return body

      	     else
      	       raise AFCS::Error, resp.code
      	  end
      	}
      end
    end

    def AFCS.http_post(url, data, headers = nil)
      puts "http_post #{url} #{data}" if DEBUG
      puts "  #{headers.inspect}" if DEBUG && headers
      uri = (url.kind_of? URI) ? url : URI.parse(url)
      http = Net::HTTP.new(uri.host, uri.port)
      if uri.scheme == "https"
      	http.use_ssl = true
      	http.verify_mode = OpenSSL::SSL::VERIFY_NONE
      end

      path = uri.path
      path << "?#{uri.query}" if uri.query

      http.start {
      	resp, body = http.post(path, data, headers)
      	puts "Host: #{resp['X-Acorn-Hostname']}" if DEBUG && resp['X-Acorn-Hostname']

      	if resp.kind_of? Net::HTTPSuccess
      	  return body
      	else
      	  raise AFCS::Error, resp.code
      	end
      }
  end

  def AFCS.check_status(response)
    status = response.elements['status']
    code = status.attributes['code']
    subcode = status.attributes['subcode']
    return code if code == "ok"
    raise AFCS::Error, subcode.nil? ? code : subcode
  end

  def AFCS.url_escape(url)
    url.gsub(/([^ a-zA-Z0-9_.-]+)/n) do
      '%' + $1.unpack('H2' * $1.size).join('%').upcase
    end.tr(' ', '+')
  end

  def AFCS.to_xml(hash, root=nil)
    result = ""

    if root
      if root == 'item'
	id = hash.has_key?('itemID') ? hash['itemID'] : 'item'
	result << "<#{root} id=\"#{id}\">"
      else
	result << "<#{root}>"
      end
    end

    hash.each { |name,value|
      if root == 'configuration'
	result << "<field var=\"#{name}\">"
      else
	result << "<property name=\"#{name}\">"
      end

      type = if value.is_a? Fixnum
	  "int"
	elsif value.is_a? Bignum
	  "long"
	elsif value.is_a? Float
	  "double"
	elsif value.is_a? String
	  "string"
	elsif value.is_a?(TrueClass) || value.is_a?(FalseClass)
	  "boolean"
	elsif value.is_a? Hash
	  "object"
	elsif value.is_a? Array
	  "array"
	else
	  "undefined:#{value.class}"
        end

      result << "<value type=\"#{type}\">"

      if value.is_a?(Hash) #|| value.is_a?(Array)
	result << AFCS::to_xml(value)
      elsif value.is_a? String
	result << REXML::Text.new(value, true).to_s
      else
	result << value.to_s
      end

      result << "</value>"

      if root == 'configuration'
	result << "</field>"
      else
	result << "</property>"
      end
    }

    result << "</#{root}>" if root
    return result
  end

  def AFCS.from_xml(xml)
    hash = {}

    xml.each { |e|
      if e.local_name == 'item'
        name = e.attributes['id']
        value = AFCS::from_xml e
      else
        if e.local_name == 'field'
	  name = e.attributes['var']	# field
        else
          name = e.attributes['name']	# property
        end

	v = e.elements['value']
        if v
	  type = v.attributes['type']
	  value = v.text

	  case type
	    when "boolean":
	      value = (value == "true")

	    when "int", "long":
	      value = value.to_i

	    when "double":
	      value = value.to_f

	    when "xml":
	      value = REXML::Document.new(value).root

	    when "object":
	      value = AFCS::from_xml v

	    when "array":
	      value = AFCS::from_xml v
	  end
        else
          value = nil
        end
      end

      hash[name] = value
    }

    return hash
  end

  #
  # parse a date/time
  # returns a DateTime
  #
  def AFCS.parseDateTime(s)
    return nil if s.nil? 
    return nil if s == 'NULL'
    #return DateTime.strptime(s, fmt='%a %b %d %H:%M:%S %Z %Y')
    return DateTime.parse(s)
  end

  #
  # parse elapsed time (days hh:mm:ss.xxx)
  # returns number of seconds
  #
  def AFCS.parseElapsed(s)
    return nil if s.nil? 
    return nil if s == 'NULL'
    empty,d,h,m,s = s.split(/\s*(\d+) (\d\d):(\d\d):(\d\d).*/)
    return (d.to_i*24 + h.to_i)*3600 + m.to_i*60 + s.to_i
  end

  #:startdoc:

end # module AFCS

if __FILE__ == $0

  def usage
    puts "usage: #{$0} [--debug] [--host=url] account user password command parameters..."
    puts ""
    puts "where <command> is:"
    puts "    --list"
    puts "    --create room [template]"
    puts "    --delete room"
    puts "    --delete-template template"
    puts "    --ext-auth secret room username userid role"
    puts "    --invalidate room"
    puts ""
    puts "    --get-node-configuration room collection node"
    puts "    --fetch-items room collection node"
    puts "    --register-hook endpoint [token]"
    puts "    --unregister-hook"
    puts "    --hook-info"
    puts "    --subscribe-collection room collection"
    puts "    --unsubscribe-collection room collection"
    puts "    --create-node room collection [node]"
    puts "    --remove-node room collection [node]"
    puts "    --set-user-role room userID role [collection [node]]"
    puts "    --publish-item room collection node itemID body"
    puts "    --retract-item room collection node itemID"
    exit 1
  end

  def getRole(r)
    case r.downcase
      when "none"      ; return AFCS::UserRole::NONE
      when "lobby"     ; return AFCS::UserRole::LOBBY
      when "viewer"    ; return AFCS::UserRole::VIEWER
      when "publisher" ; return AFCS::UserRole::PUBLISHER
      when "owner"     ; return AFCS::UserRole::OWNER
      else
        return r.to_i
    end
  end

  host = "http://connectnow.acrobat.com"

  while ARGV.length > 0
    case ARGV[0]
      when /--host=(.*)/:
	host = Regexp.last_match[1]

      when "--debug":
        AFCS::DEBUG = true

      else
        break
    end

    ARGV.shift
  end

  if ARGV.length < 3
    usage
  end

  accountName = ARGV.shift
  username = ARGV.shift
  password = ARGV.shift

  accountURL = "#{host}/#{accountName}"
  puts "account: #{accountURL}" if AFCS::DEBUG

  begin
    am = AFCS::AccountManager.new(accountURL)
    am.login(username, password)

    if ARGV.length == 0
      ARGV[0] = "--list"
    end

    while ARGV.length > 0
      case ARGV.shift

      when "--list";
	puts "==== template list for #{accountName} ===="
	am.listTemplates().each { 
	  |t| puts "#{t.name}:#{t.created.asctime}"
	}

	puts "==== room list for #{accountName} ===="
	am.listRooms().each { 
	  |r| puts "#{r.name}:#{r.templatename}:#{r.created.asctime}"
	}
      
      when "--create";
	#
	# Create a room.
	#
	room = ARGV.shift
	template = if ARGV.length > 0; then ARGV.shift else nil end
	puts am.createRoom(room, template)

      when "--delete";
	#
	# Delete a room.
	#
	room = ARGV.shift
	puts am.deleteRoom(room)

      when "--delete-template";
	#
	# Delete a template.
	#
	template = ARGV.shift
	puts am.deleteTemplate(template)

      when "--ext-auth";
	#
	# Get a session and create external authentication tokens.
	#
	secret = ARGV.shift
	room = ARGV.shift
	user = ARGV.shift
	userId = ARGV.shift

	if ARGV.length > 0
	  role = getRole(ARGV.shift)
	else
	  role = AFCS::UserRole::LOBBY
	end
	sess = am.getSession(room)
	puts sess.getAuthenticationToken(secret, user, userId, role)
	puts "userID: #{sess.getUserID(userId)}"

      when "--invalidate";
	#
	# Invalidate a session.
	#
	room = ARGV.shift
	sess = am.getSession(room)
	puts am.invalidateSession(sess)

      when "--info";
	#
	# Get account or room session information.
	#
	if ARGV.length == 0
	  puts am.getAccountInfo().inspect

	else
	  room = ARGV.shift
	  puts am.getRoomInfo(room).inspect
	end

      when "--get-node-configuration";
	room = ARGV.shift
        collection = ARGV.shift
        node = ARGV.shift
	puts am.getNodeConfiguration(room, collection, node).inspect

      when "--fetch-items";
        room = ARGV.shift
        collection = ARGV.shift
        node = ARGV.shift
	items = ARGV
        puts am.fetchItems(room, collection, node, items).inspect
	ARGV.clear
        
      when "--subscribe-collection";
	room = ARGV.shift
        collection = ARGV.shift
	nodes = ARGV
	puts am.subscribeCollection(room, collection, nodes)
	ARGV.clear

      when "--unsubscribe-collection";
	room = ARGV.shift
        collection = ARGV.shift
	nodes = ARGV
	puts am.unsubscribeCollection(room, collection, nodes)
	ARGV.clear

      when "--register-hook";
	endpoint = ARGV.length > 0 ? ARGV.shift : nil
	token = ARGV.length > 0 ? ARGV.shift : nil
	puts am.registerHook(endpoint, token)
	ARGV.clear

      when "--unregister-hook";
	puts am.registerHook()

      when "--hook-info";
	puts am.getHookInfo().inspect

      when "--create-node";
	room = ARGV.shift
	collectionName = ARGV.shift
	nodeName = ARGV.length > 0 ? ARGV.shift : nil
	puts am.createNode(room, collectionName, nodeName)

      when "--remove-node";
	room = ARGV.shift
	collectionName = ARGV.shift
	nodeName = ARGV.length > 0 ? ARGV.shift : nil
	puts am.removeNode(room, collectionName, nodeName)

      when "--set-user-role";
	room = ARGV.shift
	userID = ARGV.shift
	role = getRole(ARGV.shift)
	collectionName = ARGV.length > 0 ? ARGV.shift : nil
	nodeName = ARGV.length > 0 ? ARGV.shift : nil
	puts am.setUserRole(room, userID, role, collectionName, nodeName)

      when "--publish-item";
	room = ARGV.shift
	collectionName = ARGV.shift
	nodeName = ARGV.shift
	itemID = ARGV.shift
	body = ARGV.shift

	itemVO = { "itemID" => itemID, "body" => body }
	puts am.publishItem(room, collectionName, nodeName, itemVO)

      when "--retract-item";
	room = ARGV.shift
	collectionName = ARGV.shift
	nodeName = ARGV.shift
	itemID = ARGV.shift
	puts am.retractItem(room, collectionName, nodeName, itemID)

      else
	usage()
      end
    end

  rescue AFCS::Error => e
    puts "Error: #{e.message}"
  end
end
