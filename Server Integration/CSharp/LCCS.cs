using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.Specialized;
using System.Diagnostics;
using System.Globalization;
using System.IO;
using System.Net;
using System.Text;
using System.Xml;
using System.Security.Cryptography;
using System.Web;

using System.Xml.XPath;
using System.Xml.Serialization;

//
//
// Adobe Flash Collaboration Service Account Management API
//
// Revision
//   $Revision: #6 $ - $Date: 2011/12/01 $
//
// Author
//   Raffaele Sena
//
// Copyright 2007 - 2011 Adobe Systems Incorporated and its licensors.
// All rights reserved.
//

namespace LCCS
{
    //
    // Error - error thrown or generated by LCCS API
    //
    public class Error : Exception
    {
        public Error(string message)
            : base(message)
        {
        }
    }

    //
    // Constants for common user roles
    //
    public sealed class UserRole
    {
        public const int NONE = 0;
        public const int LOBBY = 5;
        public const int VIEWER = 10;
        public const int PUBLISHER = 50;
        public const int OWNER = 100;
    }

    //
    // Authenticator - generate LCCS authentication tokens
    //
    public class Authenticator
    {
        private string authURL;

        internal Authenticator(string url)
        {
            authURL = url;
        }

        //
        // Get an LCCS authentication token give login and password.
        //
        public string login(string user, string pw, NameValueCollection retHeaders)
        {
            NameValueCollection headers = new NameValueCollection();
            headers.Set("Content-Type", "text/xml");

            string data = "<request><username>" + user + "</username>" + "<password>" + pw + "</password></request>";

            Stream resp = Utils.http_post(authURL, data, headers);

            //if (Utils.DEBUG) Console.WriteLine(resp);

            try
            {
                XmlElement result = Utils.parseXML(resp);
                if ("ok" == result.Attributes["status"].InnerText)
                {
                    XmlElement authtoken = (XmlElement)result.GetElementsByTagName("authtoken").Item(0);
                    if ("COOKIE" == authtoken.Attributes["type"].InnerText)
                    {
                        retHeaders.Add("Cookie", authtoken.InnerText.Trim());
                        return null;
                    }
                    else
                    {
                        string gak = Utils.base64(authtoken.InnerText.Trim());
                        return "gak=" + gak;
                    }
                }
                else
                {
                    throw new Error(Utils.printXML(result));
                }
            }
            catch (Exception e)
            {
                Utils.printException(e);
                throw new Error("bad-response");
            }
        }

        //
        // Get a guest authentication token.
        //
        public string guestLogin(string user)
        {
            string guk = Utils.base64("g:" + user);
            return "guk=" + guk;
        }
    }

    //
    // Session - deals with meeting sessions and # external collaboration
    //
    public class Session
    {

        public string instance;
        public string account;
        public string room;
        public string secret;

        public Session(string instance, string account, string room)
        {
            this.instance = instance.Replace("#room#", room);
            this.account = account;
            this.room = room;
        }

        //
        // get an external authentication token
        //
        public string getAuthenticationToken(string accountSecret, string name, string id, int role)
        {
            if (role < UserRole.NONE || role > UserRole.OWNER)
                throw new Error("invalid-role");

            string token = "x:" + name + "::" + this.account + ":" + id + ":" + this.room + ":" + role.ToString();
            string signed = token + ":" + sign(accountSecret, token);

            // unencoded
            //string ext = "ext=" + signed;

            // encoded
            string ext = "exx=" + Utils.base64(signed);

            return ext;
        }

        public string getUserID(string id)
        {
            return ("EXT-" + this.account + "-" + id).ToUpper();
        }

        internal void getSecret(string baseURL, string authToken, NameValueCollection authHeaders)
        {
            Stream data = Utils.http_get(baseURL + "app/session?instance=" + this.instance + "&" + authToken, authHeaders);

            XmlElement response = Utils.parseXML(data);
            if (Utils.DEBUG)
                Console.WriteLine(Utils.printXML(response));

            XmlElement secret = (XmlElement)response.GetElementsByTagName("session-secret").Item(0);
            if (secret == null)
                throw new Error(Utils.printXML(response));

            this.secret = secret.InnerText.Trim();
        }

        internal void invalidate(string baseURL, string authToken, NameValueCollection authHeaders)
        {
            string data = "action=delete&instance=" + this.instance + "&" + authToken;
            Stream res = Utils.http_post(baseURL + "app/session", data, authHeaders);

            if (Utils.DEBUG)
            {
                XmlElement response = Utils.parseXML(res);
                Console.WriteLine(Utils.printXML(response));
            }

            this.instance = null;
            this.account = null;
            this.room = null;
            this.secret = null;
        }

        private string sign(string acctSecret, string data)
        {
            Encoding encoding = new UTF8Encoding();
            string bigSecret = acctSecret + ":" + this.secret;
            HMACSHA1 hmac = new HMACSHA1(encoding.GetBytes(bigSecret));
            byte[] computedhash = hmac.ComputeHash(encoding.GetBytes(data));
            return Utils.hexstring(computedhash);
        }
    }

    //
    // Item: Room or template item information.
    //
    public class Item
    {
        public string name;
        public string desc;
        public DateTime? created;

        public Item(string name, string desc, DateTime? created)
        {
            this.name = name;
            this.desc = desc;
            this.created = created;
        }
    }

    //
    // AccountManager - high-level account manipulation
    //
    public class AccountManager
    {
        const string ROOM_ITEMS = "meetings";
        const string TEMPLATE_ITEMS = "templates";

        public string url;

        public string authToken = "";
        private NameValueCollection authHeaders = new NameValueCollection();
        private Authenticator authenticator = null;
        private string baseURL = null;
        private string contentPath = null;
        private string roomInstance = null;

        public AccountManager(string url)
        {
            this.url = url;
            do_initialize();
        }

        string getContentURL()
        {
            return baseURL + "app/content" + contentPath;
        }

        //
        // Login into account
        //
        public bool login(string guest)
        {
            return login(guest, null);
        }

        public bool login(string user, string password)
        {
            if (password != null)
            {
                authToken = authenticator.login(user, password, authHeaders);
            }
            else
            {
                authToken = authenticator.guestLogin(user);
            }

            return do_initialize();
        }

        //
        // keep the authentication token alive by accessing the account
        //
        public bool keepalive()
        {
            return keepalive(null, null);
        }

        public bool keepalive(string user, string password)
        {
            contentPath = null;
            if (do_initialize())
                return true;
            if (user != null)
                return login(user, password);
            return false;
        }

        /**
         * Register endpoint URL for webhooks
         * 
         * @param endpoint URL for RTC callbacks
         * @throws Exception
         */
        public void registerHook(string endpoint) {
             registerHook(endpoint, null);
        }
    
        /**
         * Register endpoint URL and "validation" token for webhooks
         * 
         * @param endpoint URL for RTC callbacks
         * @param token "validation" token to pass on callbacks
         * @throws Exception
         */
        public void registerHook(string endpoint, string token)  {
            string acctid = this.roomInstance.Split('/')[0];
            string data = "account=" + acctid + "&action=registerhook";

            if (endpoint != null)
                data += "&endpoint=" + HttpUtility.UrlEncode(endpoint, Encoding.UTF8);
            if (token != null)
                data += "&token=" + HttpUtility.UrlEncode(token, Encoding.UTF8);
            data += "&" + authToken;

            Stream res = Utils.http_post(baseURL + "app/rtc", data, authHeaders);

            XmlElement result = Utils.parseXML(res);
            checkStatus(result);
        }

        /**
         * Unregister callback URL (and stop callbacks)
         * 
         * @throws Exception
         */
        public void unregisterHook()  
        {
            registerHook(null, null);
        }

        /**
         * Return callback URL and token
         * 
         * @return response as XML string
         * @throws Exception
         */
        public HookInfo getHookInfo()  {
            string acctid = this.roomInstance.Split('/')[0];
            Stream data = Utils.http_get(baseURL 
                            + "app/rtc?action=hookinfo&account=" + acctid +"&" + authToken, authHeaders);
            XmlElement result = Utils.parseXML(data);
            checkStatus(result);

            HookInfo info = new HookInfo();

            XPathNavigator nav = ((IXPathNavigable)result.OwnerDocument).CreateNavigator();
            XPathNodeIterator iter = nav.Select("//param");
            while (iter.MoveNext())
            { 
                string name = iter.Current.GetAttribute("name", String.Empty);
                if ("registerHookEndpoint".Equals(name))
                    info.endpoint = iter.Current.Value;
                else if ("registerHookToken".Equals(name)) 
                    info.token = iter.Current.Value;
            }

            return info;
        }

        /**
         * Register endpoint URL for recording repository
         * 
         * @param endpoint URL for recording repository
         * @throws Exception
         */
        public void registerRepository(string endpoint) {
            registerRepository(endpoint, null);
        }

        /**
         * Register endpoint URL and "validation" token for recording repository
         * 
         * @param endpoint URL for recording repository
         * @param token "validation" token to pass on callbacks
         * @throws Exception
         */
        public void registerRepository(string endpoint, string token)  {
            string acctid = this.roomInstance.Split('/')[0];
            string data = "account=" + acctid + "&action=registerrepository";

            if (endpoint != null)
                data += "&endpoint=" + HttpUtility.UrlEncode(endpoint, Encoding.UTF8);
            if (token != null)
                data += "&token=" + HttpUtility.UrlEncode(token, Encoding.UTF8);
            data += "&" + authToken;

            Stream res = Utils.http_post(baseURL + "app/rtc", data, authHeaders);

            XmlElement result = Utils.parseXML(res);
            checkStatus(result);
        }

        /**
         * Unregister endpoint URL for recording repository
         * 
         * @throws Exception
         */
        public void unregisterRepository()  
        {
            registerRepository(null, null);
        }

        /**
         * Start recording a specified room
         * 
         * @throws Exception
         */
        public void startRecording(string room, string archiveId, bool guestsAllowed)  
        {
            Dictionary<string, object> itemBody = new Dictionary<string, object>();
            itemBody.Add("fullSession", true);
            itemBody.Add("archiveID", archiveId);
            itemBody.Add("guestsAllowed", guestsAllowed);

            Dictionary<string, object> itemVO = new Dictionary<string, object>();
            itemVO.Add("itemID", "recordingState");
            itemVO.Add("body", itemBody);
            publishItem(room, "RoomManager", "roomState", itemVO);
        }

        /**
         * Stop recording a specified room
         * 
         * @throws Exception
         */
        public void stopRecording(string room)  
        {
            retractItem(room, "RoomManager", "roomState", "recordingState");
        }

        /**
         * Return repository URL and token
         * 
         * @return response as XML string
         * @throws Exception
         */
        public HookInfo getRepositoryInfo()  {
            string acctid = this.roomInstance.Split('/')[0];
            Stream data = Utils.http_get(baseURL 
                    + "app/rtc?action=repositoryinfo&account=" + acctid +"&" + authToken, authHeaders);
            XmlElement result = Utils.parseXML(data);
            checkStatus(result);

            HookInfo info = new HookInfo();

            XPathNavigator nav = ((IXPathNavigable)result.OwnerDocument).CreateNavigator();
            XPathNodeIterator iter = nav.Select("//param");
            while (iter.MoveNext())
            { 
                string name = iter.Current.GetAttribute("name", String.Empty);
                if ("repositoryEndpoint".Equals(name))
                    info.endpoint = iter.Current.Value;
                else if ("repositoryToken".Equals(name)) 
                    info.token = iter.Current.Value;                
            }

            return info;
        }

        /**
         * Subscribe to collection event
         * 
         * @param room room name
         * @param collectionName collection name
         * @throws Exception
         */
        public void subscribeCollection(string room, string collectionName) {
            subscribeCollection(room, collectionName, null);
        }

        internal void subscribeCollection(string room, string collection, string[] nodeNames) {
            string instance = this.roomInstance.Replace("#room#", room);
            string data = "instance=" + instance + "&action=subscribe" + "&collection=" + collection;

            if (nodeNames != null) {
                    foreach (string node in nodeNames)
                            data += "&node=" + node;
            }

            data += "&" + authToken;

            Stream res = Utils.http_post(baseURL + "app/rtc", data, authHeaders);

            XmlElement result = Utils.parseXML(res);
            checkStatus(result);
        }

        /**
         * Publish an item
         *
         * @param room room name
         * @param collectionName collection name
         * @param nodeName node name
         * @param itemVO item VO (as returned from LCDS)
         * @throws Exception
         */
        public void publishItem(string room, string collectionName, string nodeName, Dictionary<String, Object> itemVO) 
        {
            publishItem(room, collectionName, nodeName, itemVO, false);
        }

        /**
         * Publish an item
         *
         * @param room room name
         * @param collectionName collection name
         * @param nodeName node name
         * @param item MessageItem to publish
         * @param overwrite overwrite or create
         * @throws Exception
         * @see MessageItem
         */
        public void publishItem(string room, string collectionName, string nodeName, Dictionary<String, Object> itemVO, bool overwrite)
        {
            string instance = this.roomInstance.Replace("#room#", room);

            NameValueCollection headers = new NameValueCollection();
            headers.Add("Content-Type", "text/xml");
            foreach (string key in authHeaders.Keys)
            {
                headers.Add(key, authHeaders.GetValues(key)[0]); 
            }

            string parameters = "instance=" + instance + "&action=publish&collection=" + collectionName + "&node=" + nodeName;
            if (overwrite)
                    parameters += "&overwrite=true";

            parameters += "&" + authToken;

            string data = "<request>" +Utils.dictionary_toXML(itemVO, "item") + "</request>";
            Stream res = Utils.http_post(baseURL + "app/rtc?" + parameters, data, headers);

            XmlElement result = Utils.parseXML(res);
            checkStatus(result);
        }

         /**
         * Remove a collection
         *
         * @param room room name
         * @param collectionName collection name
         * @throws Exception
         */
        public void removeNode(string room, string collectionName) {
            removeNode(room, collectionName, null);
        }

        /**
         * Remove a node
         *
         * @param room room name
         * @param collectionName collection name
         * @param nodeName node name
         * @throws Exception
         */
        public void removeNode(string room, string collectionName, string nodeName) {
            string instance = this.roomInstance.Replace("#room#", room);
            string data = "instance=" + instance + "&action=remove"
                            + "&collection=" + collectionName;

            if (nodeName != null)
                    data += "&node=" + nodeName;

            data += "&" + authToken;

            Stream res = Utils.http_post(baseURL + "app/rtc", data, authHeaders);

            XmlElement result = Utils.parseXML(res);
            checkStatus(result);
        }

        /**
         * Retract an item
         *
         * @param room room name
         * @param collectionName collection name
         * @param nodeName node name
         * @param itemID item ID
         * @throws Exception
         */
        public void retractItem(string room, string collectionName, string nodeName, string itemID) 
        {
            string instance = this.roomInstance.Replace("#room#", room);
            string data = "instance=" + instance
                + "&collection=" + collectionName + "&node=" + nodeName + "&item=" + itemID + "&" + authToken;

            Stream res = Utils.http_post(baseURL + "app/rtc", data, authHeaders);

            XmlElement result = Utils.parseXML(res);
            checkStatus(result);
        }

        /**
         * Configure a node
         *
         * @param room room name
         * @param collectionName collection name
         * @param nodeName node name
         * @param configuration configuration VO (as returned from LCDS)
         * @throws Exception
         */
        public void setNodeConfiguration(string room, string collectionName, string nodeName, Dictionary<string, object> configuration)
        {
            if (configuration == null) return;
            string instance = this.roomInstance.Replace("#room#", room);
            string parameters = "instance=" + instance + "&action=configure"
                    + "&collection=" + collectionName + "&node=" + nodeName + "&" + authToken;

            NameValueCollection headers = new NameValueCollection();
            headers.Add("Content-Type", "text/xml");
            foreach (string key in authHeaders.Keys)
            {
                headers.Add(key, authHeaders.GetValues(key)[0]);
            }

            string data = "<request>" + Utils.dictionary_toXML(configuration, "configuration") + "</request>";
            Stream res = Utils.http_post(baseURL + "app/rtc?" + parameters, data, headers);

            XmlElement result = Utils.parseXML(res);
            checkStatus(result);
        }

         /* Set user role
         *
         * @param room room name
         * @param userID user ID
         * @param role role value
         * @throws Exception
         * @see UserRoles
         */
        public void setUserRole(string room, string userID, int role) {
            setUserRole(room, userID, role, null, null);
        }

        /**
         * Set user role for the specified collection
         *
         * @param room room name
         * @param userID user ID
         * @param role role value
         * @param collectionName collection name
         * @throws Exception
         * @see UserRoles
         */
        public void setUserRole(string room, string userID, int role, string collectionName)  {
            setUserRole(room, userID, role, collectionName, null);
        }

        /**
         * Set user role for the specified node
         *
         * @param room room name
         * @param userID user ID
         * @param role role value
         * @param collectionName collection name
         * @param nodeName node name
         * @throws Exception
         * @see UserRoles
         */
        public void setUserRole(string room, string userID, int role, string collectionName, string nodeName)  {
            string instance = this.roomInstance.Replace("#room#", room);
            string data = "instance=" + instance + "&action=setrole&user=" + userID + "&role=" + role;

            if (collectionName != null)
                    data += "&collection=" + collectionName;
            if (nodeName != null)
                    data += "&node=" + nodeName;

            data += "&" + authToken;

            Stream res = Utils.http_post(baseURL + "app/rtc", data, authHeaders);

            XmlElement result = Utils.parseXML(res);
            checkStatus(result);
        }

        //
        // Create room
        //
        public void createRoom(string room)
        {
            createRoom(room, null, false);
        }

        public void createRoom(string room, string template)
        {
            createRoom(room, template, false);
        }

        public void createRoom(string room, bool deleteOnExit)
        {
            createRoom(room, null, deleteOnExit);
        }

        public void createRoom(string room, string template, bool deleteOnExit)
        {

            if (template == null)
            {
                template = "default";
            }

            string data = "mode=xml&room=" + room + "&template=" + template;

            if (deleteOnExit)
                data += "&deleteonexit=true";

            if (authToken != null)
                data += "&" + authToken;

            Utils.http_post(url, data, authHeaders);
        }

        //
        // List rooms or templates
        //
        public List<Item> listItems()
        {
            return listItems(null);
        }

        public List<Item> listItems(string type)
        {

            if (type != AccountManager.TEMPLATE_ITEMS)
                type = AccountManager.ROOM_ITEMS;

            List<Item> items = new List<Item>();

            Stream data = Utils.http_get(getContentURL() + "/" + type + "/?" + authToken, authHeaders);

            //if (Utils.DEBUG) Console.WriteLine(data);

            XmlElement repository = null;

            try
            {
                repository = Utils.parseXML(data);
            }
            catch (Exception e)
            {
                Utils.printException(e);
                throw new Error("bad-response");
            }

            XmlElement children = (XmlElement)repository.GetElementsByTagName("children").Item(0);
            if (children == null)
                // no children
                return items;

            XmlNodeList nodes = children.GetElementsByTagName("node");
            for (int i = 0; i < nodes.Count; i++)
            {
                XmlElement n = (XmlElement)nodes.Item(i);
                string name = n.GetElementsByTagName("name").Item(0).InnerText.Trim();
                string desc = null;
                DateTime? created = null;
                XmlNodeList properties = n.GetElementsByTagName("property");
                for (int j = 0; j < properties.Count; j++)
                {
                    XmlElement p = (XmlElement)properties.Item(j);
                    if (p.Attributes["name"].InnerText == "cr:description")
                    {
                        desc = p.InnerText.Trim();
                    }
                    else if (p.Attributes["name"].InnerText == "jcr:created")
                    {
                        string raw = p.InnerText.Trim();
                        // ends with "-HH:MM" for timezone and we need to turn this into " -HHMM" so that it will parse!
                        // raw = raw.Substring (0, raw.Length - 6) + " " + raw.Substring (raw.Length - 6, 3) + raw.Substring (raw.Length - 2, 2);

                        // remove 'T'
                        raw = raw.Substring(0, 10) + ' ' + raw.Substring(11, raw.Length - 11 - 6) + ' ' + raw.Substring(raw.Length - 6, 6);
                        created = DateTime.ParseExact(raw, "yyyy-MM-dd HH:mm:ss.fff zzz", CultureInfo.InvariantCulture);
                    }
                }

                items.Add(new Item(name, desc, created));
            }

            return items;
        }

        //
        // delete room or template
        //
        public void delete(string item)
        {
            delete(item, null, false);
        }

        public void delete(string item, string type)
        {
            delete(item, type, false);
        }

        public void delete(string item, string type, bool list)
        {

            if (!AccountManager.TEMPLATE_ITEMS.Equals(type))
            {
                type = AccountManager.ROOM_ITEMS;
            }

            string limitCount = list ? "" : "&count=0";
            string data = "action=delete&response=inline" + limitCount + "&" + authToken;
            Utils.http_post(getContentURL() + "/" + type + "/" + item, data, authHeaders);
        }

        //
        // List rooms
        //
        public List<Item> listRooms()
        {
            return listItems(AccountManager.ROOM_ITEMS);
        }

        //
        // List templates
        //
        public List<Item> listTemplates()
        {
            return listItems(AccountManager.TEMPLATE_ITEMS);
        }

        //
        // Delete room
        //
        public void deleteRoom(string r)
        {
            deleteRoom(r, false);
        }

        public void deleteRoom(string r, bool list)
        {
            if (r == null)
                throw new Error("parameter-required");
            delete(r.ToLower(), AccountManager.ROOM_ITEMS, list);
        }

        //
        // Delete template
        //
        public void deleteTemplate(string t)
        {
            deleteTemplate(t, false);
        }

        public void deleteTemplate(string t, bool list)
        {
            if (t == null)
                throw new Error("parameter-required");
            delete(t, AccountManager.TEMPLATE_ITEMS, list);
        }

        //
        // Return a room session for external authentication
        //
        public Session getSession(string room)
        {
            string[] parts = this.url.Split('/');
            Session session = new Session(this.roomInstance, parts[parts.Length - 1], room);
            session.getSecret(this.baseURL, this.authToken, this.authHeaders);
            return session;
        }

        //
        // invalidate room session
        //
        public void invalidateSession(Session session)
        {
            session.invalidate(this.baseURL, this.authToken, this.authHeaders);
        }

        //
        // Return the LCCS nodes @ path
        //
        public string getNodes(string room, string path)
        {
            string instance = this.roomInstance.Replace("#room#", room);
            Stream data = Utils.http_get(baseURL + "app/collections?instance=" + instance + "&path=" + path + "&" + authToken, authHeaders);
            XmlElement result = Utils.parseXML(data);
            return Utils.printXML(result);
        }

        //
        // Return information about the account, if active
        //
        public string getAccountInfo()
        {
            string acctid = this.roomInstance.Split('/')[0];
            Stream data = Utils.http_get(baseURL + "app/account?account=" + acctid + "&" + authToken, authHeaders);
            XmlElement result = Utils.parseXML(data);
            return Utils.printXML(result);
        }

        //
        // Return information about the room/instance, if active
        //
        public string getRoomInfo(string room)
        {
            string instance = room;

            if (room.IndexOf('/') < 0)
                instance = this.roomInstance.Replace("#room#", room);

            Stream data = Utils.http_get(baseURL + "app/account?instance=" + instance + "&" + authToken, authHeaders);
            XmlElement result = Utils.parseXML(data);
            return Utils.printXML(result);
        }

        /**
         * Return the node configuration
         * 
         * @param room room name
         * @param collectionName collection name
         * @param nodeName node name
         * @return the node configuration
         * @throws Exception
         * @see NodeConfiguration
         */
        public Dictionary<string, object> getNodeConfiguration(string room, string collectionName, string nodeName) 
        {
            Dictionary<string, object> result = new Dictionary<string, object>();

                    string instance = this.roomInstance.Replace("#room#", room);
                    string path = "/" + collectionName + "/nodes/" + nodeName + "/configuration";
                    Stream data = Utils.http_get(baseURL + "app/rtc?instance=" + instance + "&path=" + path + "&" + authToken, authHeaders);

                    XmlElement xmlData = Utils.parseXML(data);
            XPathNavigator nav = ((IXPathNavigable) xmlData.OwnerDocument).CreateNavigator();
            XPathNodeIterator iter = nav.Select("//configuration");
            while (iter.MoveNext())
            {
                XPathNodeIterator newIter = iter.Current.SelectDescendants(XPathNodeType.Element, false);
                while (newIter.MoveNext())
                {
                    if (newIter.Current.Name.Equals("field"))
                    {
                        result.Add(newIter.Current.GetAttribute("var", String.Empty), newIter.Current.Value);
                    }
                }
            }

            return result;
        }

        /**
         * Return all items for the specified collection and node
         * 
         * @param room room name
         * @param collectionName collection name
         * @param nodeName node name
         * @return a list of MessageItem
         * @throws Exception
         * @see MessageItem
         */
        public ICollection<Dictionary<string, object>> fetchItems(String room, String collectionName, String nodeName)
        {
            return fetchItems(room, collectionName, nodeName, null);
        }

        /**
         * Return the specified items for the collection and node
         * 
         * @param room room name
         * @param collectionName collection name
         * @param nodeName node name
         * @param itemIDs list of itemID
         * @return a list of MessageItem
         * @throws Exception
         * @see MessageItem
         */
        public ICollection<Dictionary<string, object>> fetchItems(string room, string collectionName, string nodeName, string[] itemIDs)  
        {
            List<Dictionary<string, object>> fetchedItems = new List<Dictionary<string, object>>();
            string instance = this.roomInstance.Replace("#room#", room);
            string parameters = "instance=" + instance + "&collection=" + collectionName + "&node=" + nodeName;

            if (itemIDs != null) 
            {
                foreach (string item in itemIDs)
                {
                    parameters += "&item=" + item;
                }
            }

            Stream data = Utils.http_get(baseURL + "app/rtc?" + parameters + "&" + authToken, authHeaders);

            XmlElement xmlData = Utils.parseXML(data);
            XPathNavigator nav = ((IXPathNavigable)xmlData.OwnerDocument).CreateNavigator();
            XPathNodeIterator iter = nav.Select("//items");
            while (iter.MoveNext())
            {
                XPathNodeIterator newIter = iter.Current.SelectDescendants(XPathNodeType.Element, false);
                while (newIter.MoveNext())
                {
                    if (newIter.Current.Name.Equals("item"))
                    {
                        XPathNodeIterator itemIter = newIter.Current.SelectDescendants(XPathNodeType.Element, false);
                        Dictionary<string, object> messageItem = new Dictionary<string, object>();
                        while (itemIter.MoveNext())
                        {
                            string name = itemIter.Current.GetAttribute("name", String.Empty);
                            if(name != null && name.Length > 0)
                                messageItem.Add(name , itemIter.Current.Value);
                        }
    
                        fetchedItems.Add(messageItem);
                    }
                }
            }
    
            return fetchedItems;
        }

        /**
         * Unsubscribe from collection events (and stop notifications)
         *
         * @param room room name
         * @param collectionName collection name
         * @throws Exception
         */
        public void unsubscribeCollection(string room, string collectionName) {
            unsubscribeCollection(room, collectionName, null);
        }

        protected void unsubscribeCollection(string room, string collection, string[] nodeNames)  {
            string instance = this.roomInstance.Replace("#room#", room);
            string data = "instance=" + instance + "&action=unsubscribe" + "&collection=" + collection;

            if (nodeNames != null) {
                foreach(string node in nodeNames)
                    data += "&node=" + node;
            }

            data += "&" + authToken;

            Stream res = Utils.http_post(baseURL + "app/rtc", data, authHeaders);

            XmlElement result = Utils.parseXML(res);
            checkStatus(result);
        }

         /**
         * Create a node with specified node configuration
         *
         * @param room room name
         * @param collectionName collection name
         * @param nodeName node name
         * @param configurationVO configuration VO (as returned from LCDS)
         * @throws Exception
         */
        public void createNode(string room, string collectionName, string nodeName) 
        {
            createNode(room, collectionName, nodeName, null);
        }

        /**
         * Create a node with specified node configuration
         *
         * @param room room name
         * @param collectionName collection name
         * @param nodeName node name
         * @param configuration NodeConfiguration
         * @throws Exception
         * @see NodeConfiguration
         */
        public void createNode(string room, string collectionName, string nodeName, Dictionary<string, object> configuration)

        {
            string instance = this.roomInstance.Replace("#room#", room);
            string parameters = "instance=" + instance + "&action=configure"
            + "&collection=" + collectionName + "&node=" + nodeName + "&" + authToken;

            Stream res;

            if (configuration != null) {
                NameValueCollection headers = new NameValueCollection();
                headers.Add("Content-Type", "text/xml");
                foreach (string key in authHeaders.Keys)
                {
                    headers.Add(key, authHeaders.GetValues(key)[0]);
                }

                string data = "<request>" + Utils.dictionary_toXML(configuration, "configuration") + "</request>";
                res = Utils.http_post(baseURL + "app/rtc?" + parameters, data, headers);
            } else {
                res = Utils.http_post(baseURL + "app/rtc", parameters, authHeaders);
            }

            XmlElement result = Utils.parseXML(res);
            checkStatus(result);
        }


        private bool do_initialize()
        {
            if (contentPath != null)
                return true;

            Stream data = Utils.http_get(url + "?mode=xml&accountonly=true&" + authToken, authHeaders);

            //if (Utils.DEBUG) Console.WriteLine(data);

            try
            {

                XmlElement result = Utils.parseXML(data);

                if (result.Name.Equals("meeting-info"))
                {
                    XmlElement baseURL = (XmlElement)result.GetElementsByTagName("baseURL").Item(0);
                    this.baseURL = baseURL.Attributes["href"].InnerText;
                    url = this.baseURL + new Uri(url).PathAndQuery.Substring(1);
                    XmlElement accountPath = (XmlElement)result.GetElementsByTagName("accountPath").Item(0);
                    contentPath = accountPath.Attributes["href"].InnerText;
                    XmlNodeList room = result.GetElementsByTagName("room");
                    if (room != null)
                    {
                        this.roomInstance = ((XmlElement)room.Item(0)).Attributes["instance"].InnerText;
                    }

                    return true;
                }

                if (result.Name == "result")
                {
                    if (result.Attributes["code"].InnerText == "unauthorized")
                    {
                        XmlNodeList baseURL = result.GetElementsByTagName("baseURL");
                        if (baseURL != null)
                        {
                            this.baseURL = ((XmlElement)baseURL.Item(0)).Attributes["href"].InnerText;
                            url = this.baseURL + new Uri(url).PathAndQuery.Substring(1);
                        }
                        XmlElement authentication = (XmlElement)result.GetElementsByTagName("authentication").Item(0);
                        string authURL = authentication.Attributes["href"].InnerText;
                        if (authURL[0] == '/')
                            authURL = this.baseURL + authURL;
                        authenticator = new Authenticator(authURL);
                        return false;
                    }
                }

                throw new Error(Utils.printXML(result));
            }
            catch (Exception e)
            {
                Utils.printException(e);
                throw new Error("bad-response");
            }
        }

        internal void checkStatus(XmlElement result)
        {
            if (result == null)
                throw new Error("bad-response");

            XmlElement status = (XmlElement)result.GetElementsByTagName("status").Item(0);
            string code = status.GetAttribute("code");
            if (!"ok".Equals(code))
            {
                if (status.GetAttribute("subcode") != null)
                    code = status.GetAttribute("subcode");
                throw new Error(code);
            }
        }
    }

    //
    // Utility methods
    //
    public static class Utils
    {
        public static bool DEBUG = false;

        public static void setDebug(bool value)
        {
            DEBUG = value;
        }

        public static Stream http_get(string url, NameValueCollection headers)
        {
            if (DEBUG)
            {
                Console.WriteLine("http_get: " + url);
                if (headers != null)
                    for (int i = 0; i < headers.Count; i++)
                        Console.WriteLine("  {0}: {1}", headers.GetKey(i), headers.Get(i));
            }

            HttpWebRequest request = (HttpWebRequest)WebRequest.Create(url);
            request.AllowAutoRedirect = false;

            if (headers != null)
                request.Headers.Add(headers);

            HttpWebResponse response;

            try
            {
                response = (HttpWebResponse)request.GetResponse();
            }
            catch (WebException we)
            {
                response = (HttpWebResponse)we.Response;
            }

            HttpStatusCode responseCode = response.StatusCode;

            if (responseCode == HttpStatusCode.OK)
            {
                if (Utils.DEBUG)
                {
                    Console.WriteLine("Content-Type: " + response.ContentType);
                    Console.WriteLine("Content-Length: " + response.ContentLength);
                }

                return response.GetResponseStream();
            }
            
            else if (responseCode == HttpStatusCode.Redirect)
            {
                if (Utils.DEBUG)
                    Console.WriteLine("Redirecting to " + response.GetResponseHeader("Location"));

                return http_get(response.GetResponseHeader("Location"), headers);

            }
            
            else
            {
                if (Utils.DEBUG)
                {
                    Console.WriteLine("HTTP error " + responseCode);
                    StreamReader sr = new StreamReader(response.GetResponseStream());
                    Console.WriteLine(sr.ReadToEnd());
                }

                throw new Exception("GET " + url + " failed with status " + responseCode);
            }
        }

        public static Stream http_post(string url, string data, NameValueCollection headers)
        {
            if (Utils.DEBUG)
            {
                Console.WriteLine("http_post: " + url + " " + data);
                if (headers != null)
                    for (int i = 0; i < headers.Count; i++)
                        Console.WriteLine("  {0}: {1}", headers.GetKey(i), headers.Get(i));
            }

            HttpWebRequest request = (HttpWebRequest)WebRequest.Create(url);
            request.AllowAutoRedirect = false;
            request.Method = "POST";

            if (headers != null)
            {
                if (headers["Content-Type"] != null)
                {
                    request.ContentType = headers["Content-Type"];
                    headers.Remove("Content-Type");
                }
                else
                    request.ContentType = "application/x-www-form-urlencoded";

                if (headers.Count > 0)
                    request.Headers.Add(headers);
            }

            Encoding encoding = new UTF8Encoding();
            byte[] dataBytes = encoding.GetBytes(data);

            request.ContentLength = dataBytes.Length;

            Stream requestStream = request.GetRequestStream();
            requestStream.Write(dataBytes, 0, dataBytes.Length);
            requestStream.Close();

            HttpWebResponse response;

            try
            {
                response = (HttpWebResponse)request.GetResponse();
            }
            catch (WebException we)
            {
                response = (HttpWebResponse)we.Response;
            }

            HttpStatusCode responseCode = response.StatusCode;

            if (responseCode == HttpStatusCode.OK)
            {
                if (Utils.DEBUG)
                {
                    Console.WriteLine("Content-Type: " + response.ContentType);
                    Console.WriteLine("Content-Length: " + response.ContentLength);
                }

                return response.GetResponseStream();
            }
            
            else if (responseCode == HttpStatusCode.Redirect)
            {
                if (Utils.DEBUG)
                    Console.WriteLine("Redirecting to " + response.GetResponseHeader("Location"));

                return http_post(response.GetResponseHeader("Location"), data, headers);
            }
            
            else
            {
                if (Utils.DEBUG)
                {
                    Console.WriteLine("HTTP error " + responseCode);
                    StreamReader sr = new StreamReader(response.GetResponseStream());
                    Console.WriteLine(sr.ReadToEnd());
                }

                throw new Exception("POST " + url + " failed with status " + responseCode);
            }

        }

        public static string hexstring(byte[] bytes)
        {
            StringBuilder sb = new StringBuilder();

            foreach (byte b in bytes)
            {
                string c = b.ToString("x");
                if (c.Length == 1)
                    sb.Append("0");
                sb.Append(c);
            }

            return sb.ToString();
        }

        private const string base64code = "ABCDEFGHIJKLMNOPQRSTUVWXYZ" + "abcdefghijklmnopqrstuvwxyz" + "0123456789" + "+/";

        public static string base64(string s)
        {
            StringBuilder encoded = new StringBuilder();
            int padding = (3 - (s.Length % 3)) % 3;
            s += "\0\0".Substring(0, padding);
            for (int i = 0; i < s.Length; i += 3)
            {
                int j = (s[i] << 16) + (s[i + 1] << 8) + s[i + 2];
                encoded.Append(base64code[(j >> 18) & 0x3f]);
                encoded.Append(base64code[(j >> 12) & 0x3f]);
                encoded.Append(base64code[(j >> 6) & 0x3f]);
                encoded.Append(base64code[j & 0x3f]);
            }

            encoded.Remove(encoded.Length - padding, padding).Append("==".Substring(0, padding));
            return encoded.ToString();
        }

        public static XmlElement parseXML(string xmldata)
        {
            XmlDocument doc = new XmlDocument();
            doc.LoadXml(xmldata);
            return doc.DocumentElement;
        }

        public static XmlElement parseXML(Stream input)
        {
            XmlDocument doc = new XmlDocument();
            doc.Load(input);
            return doc.DocumentElement;
        }

        public static string printXML(XmlElement root)
        {
            return root.OuterXml;
        }

        public static void printException(Exception e)
        {
            Console.WriteLine("Exception " + e);

            StackTrace st = new StackTrace(e);
            string stackIndent = "";

            for (int i = 0; i < st.FrameCount; i++)
            {
                StackFrame sf = st.GetFrame(i);
                Console.WriteLine();
                Console.WriteLine(stackIndent + " Method: {0}", sf.GetMethod());
                Console.WriteLine(stackIndent + " File: {0}", sf.GetFileName());
                Console.WriteLine(stackIndent + " Line Number: {0}", sf.GetFileLineNumber());
                stackIndent += "  ";
            }
        }

        public static string dictionary_toXML(Dictionary<string, object> a, string root)
        {
            string result = "";
            if (root != null)
            {
                if (root.Equals("item", StringComparison.OrdinalIgnoreCase))
                {
                    string id = "item";
                    if (a.ContainsKey("itemID"))
                    {
                        id = a["itemID"].ToString();
                    }
                    result += "<" + root + " id= \"" + id + "\">";
                }
                else
                {
                    result += "<" + root + ">";
                }   
            }

            foreach (string key in a.Keys)
            {
                if (root != null && root.Equals("configuration", StringComparison.OrdinalIgnoreCase))
                    result += "<field var=\"" + key +" \">";
                else
                    result += "<property name=\"" + key + "\">";

                result += "<value type=\"";
                object value = a[key];
                if (value is Dictionary<string, object>)
                    result += "object";
                else if (value is string)
                    result += "string";
                else if (value is float)
                    result += "double";
                else if (value is int)
                    result += "int";
                else if (value is bool)
                    result += "boolean";
                else
                    result += "unknown";

                result += "\">";

                if (value is Dictionary<string, object>)
                {
                    result += dictionary_toXML((Dictionary<string, object>)value, null);
                }
                else
                    result += value;

                result += "</value>";

                if(root!=null && root.Equals("configuration", StringComparison.OrdinalIgnoreCase))
                    result += "</field>";
                else 
                    result += "</property>";
            }

            if(root!=null)
                result += "</" + root +">";

            return result;
        }

    }
    public class HookInfo
    {
        public string endpoint;
        public string token;

        override public string ToString()
        {
            return "{endpoint:" + endpoint + ", token:" + token + "}";
        }
    }

    //
    // A simple command line utility
    //
    class MainClass
    {
        private static void usage(string progname)
        {
            Console.WriteLine("usage: " + progname + " [--debug] [--host=url] account user password");
            Console.WriteLine("    --list");
            Console.WriteLine("    --create room [template]");
            Console.WriteLine("    --create-autodelete room [template]");
            Console.WriteLine("    --delete room");
            Console.WriteLine("    --delete-template template");
            Console.WriteLine("    --ext-auth secret room username userid role");
            Console.WriteLine("    --invalidate room");
            Console.WriteLine("");
            Console.WriteLine("    --get-node-configuration room collection node");
            Console.WriteLine("    --fetch-items room collection node");
            Console.WriteLine("    --register-hook endpoint [token]");
            Console.WriteLine("    --unregister-hook");
            Console.WriteLine("    --hook-info");
            Console.WriteLine("    --subscribe-collection room collection");
            Console.WriteLine("    --unsubscribe-collection room collection");
            Console.WriteLine("    --create-node room collection [node]");
            Console.WriteLine("    --remove-node room collection [node]");
            Console.WriteLine("    --set-user-role room userID role [collection [node]]");
            Console.WriteLine("    --publish-item room collection node itemID body");
            Console.WriteLine("    --retract-item room collection node itemID");
            Console.WriteLine("");    
            Console.WriteLine("    --register-repository endpoint [token]");
            Console.WriteLine("    --unregister-repository");
            Console.WriteLine("    --repository-info");
            Console.WriteLine("    --start-recording room [[archiveId] [guestsAllowed]]"); 
            Console.WriteLine("    --stop-recording room");
            Environment.Exit(1);
        }

        private static int getRole(String sRole) {
            if (sRole.Equals("none"))
                return UserRole.NONE;
            else if (sRole.Equals("lobby"))
                return UserRole.LOBBY;
            else if (sRole.Equals("viewer"))
                return UserRole.VIEWER;
            else if (sRole.Equals("publisher"))
                return UserRole.PUBLISHER;
            else if (sRole.Equals("owner"))
                return UserRole.OWNER;
            else
                return int.Parse(sRole);
        }

        public static void Main(string[] args)
        {
            string progname = "lccs";
            string host = "http://collaboration.adobelivecycle.com";
            int argc = 0;

            while (argc < args.Length)
            {
                string arg = args[argc];

                if (arg.StartsWith("--host="))
                    host = arg.Substring(7);
                else if (arg.Equals("--debug"))
                    Utils.DEBUG = true;
                else
                    break;

                argc++;
            }

            if (args.Length - argc < 3)
                usage(progname);

            string account = args[argc++];
            string username = args[argc++];
            string password = args[argc++];

            AccountManager am = new AccountManager(host + "/" + account);
            am.login(username, password);

            if (args.Length - argc == 0 || args[argc].Equals("--list"))
            {
                Console.WriteLine("==== template list for " + account + " ====");
                try
                {
                    foreach (Item aTemplate in am.listTemplates())
                    {
                        Console.WriteLine(aTemplate.name + " : " + aTemplate.created);
                    }
                }
                catch (Exception e)
                {
                    Utils.printException(e);
                }

                Console.WriteLine("==== room list for " + account + " ====");
                try
                {
                    foreach (Item aRoom in am.listRooms())
                    {
                        Console.WriteLine(aRoom.name + " : " + aRoom.desc + " : " + aRoom.created);
                    }
                }
                catch (Exception e)
                {
                    Utils.printException(e);
                }

            }
            else if (args[argc].Equals("--create"))
            {
                am.createRoom(args[argc + 1], (args.Length - argc) > 2 ? args[argc + 2] : null);

            }
            else if (args[argc].Equals("--create-autodelete"))
            {
                am.createRoom(args[argc + 1], (args.Length - argc) > 2 ? args[argc + 2] : null, true);

            }            
            else if (args[argc].Equals("--delete"))
            {
                am.deleteRoom(args[argc + 1]);

            }
            else if (args[argc].Equals("--delete-template"))
            {
                am.deleteTemplate(args[argc + 1]);

            }
            else if (args[argc].Equals("--ext-auth"))
            {
                int role = UserRole.LOBBY;

                if (args.Length - argc >= 6)
                    role = getRole(args[argc + 5].ToLower());

                Session session = am.getSession(args[argc + 2]);
                string token = session.getAuthenticationToken(args[argc + 1], args[argc + 3], args[argc + 4], role);
                Console.WriteLine(token);
                Console.WriteLine("userID: " + session.getUserID(args[argc + 4]));

            }
            else if (args[argc].Equals("--invalidate"))
            {
                Session session = am.getSession(args[argc + 1]);
                am.invalidateSession(session);

            }
            else if (args[argc].Equals("--info"))
            {
                if ((args.Length - argc) == 1)
                    Console.WriteLine(am.getAccountInfo());
                else
                    Console.WriteLine(am.getRoomInfo(args[argc + 1]));

            }
            else if (args[argc].Equals("--get-nodes"))
            {
                Console.WriteLine(am.getNodes(args[argc + 1], args[argc + 2]));
            }

            else if (args[argc].Equals("--get-node-configuration")) {
                    Console.WriteLine(am.getNodeConfiguration(args[argc+1], args[argc+2], args[argc+3]));
            }

            else if (args[argc].Equals("--fetch-items")) {
                    Console.WriteLine(am.fetchItems(args[argc+1], args[argc+2], args[argc+3]));
            }

            else if (args[argc].Equals("--register-hook")) {
                    string endpoint = args[argc+1];
                    string token = (args.Length - argc) > 2 ? args[argc+2] : null;
                    am.registerHook(endpoint, token);
            }

            else if (args[argc].Equals("--unregister-hook")) {
                    am.unregisterHook();
            }

            else if (args[argc].Equals("--hook-info")) {
                    Console.WriteLine(am.getHookInfo());
            }

            else if (args[argc].Equals("--register-repository")) {
                    string endpoint = args[argc+1];
                    string token = (args.Length - argc) > 2 ? args[argc+2] : null;
                    am.registerRepository(endpoint, token);
            }

            else if (args[argc].Equals("--unregister-repository")) {
                    am.unregisterRepository();
            }

            else if (args[argc].Equals("--repository-info")) {
                    Console.WriteLine(am.getRepositoryInfo());
            }

            else if (args[argc].Equals("--start-recording")) {
                    string room = args[argc+1];
                    string archiveId = (args.Length - argc) > 2 ? args[argc+2] : "__defaultArchive__";
                    bool guestsAllowed = (args.Length - argc) > 3 ? args[argc+3].Equals("true") : true;
                    am.startRecording(room, archiveId, guestsAllowed);
            }

            else if (args[argc].Equals("--stop-recording")) {
                    string room = args[argc+1];
                    am.stopRecording(room);
            }

            else if (args[argc].Equals("--subscribe-collection")) {
                    string room = args[argc+1];
                    string collectionName = args[argc+2];
                    am.subscribeCollection(room, collectionName);
            }

            else if (args[argc].Equals("--unsubscribe-collection")) {
                    string room = args[argc+1];
                    string collectionName = args[argc+2];
                    am.unsubscribeCollection(room, collectionName);
            }

            else if (args[argc].Equals("--create-node")) {
                    String room = args[argc+1];
                    String collectionName = args[argc+2];
                    String nodeName = (args.Length - argc) > 3 ? args[argc+3] : null;
                    am.createNode(room, collectionName, nodeName);
            }

            else if (args[argc].Equals("--remove-node")) {
                    string room = args[argc+1];
                    string collectionName = args[argc+2];
                    string nodeName = (args.Length - argc) > 3 ? args[argc+3] : null;
                    am.removeNode(room, collectionName, nodeName);
            }

            else if (args[argc].Equals("--set-user-role")) {
                    string room = args[argc+1];
                    string userID = args[argc+2];
                    int role = getRole(args[argc+3]);
                    string collectionName = (args.Length - argc) > 4 ? args[argc+4] : null;
                    string nodeName = (args.Length - argc) > 5 ? args[argc+5] : null;
                    am.setUserRole(room, userID, role, collectionName, nodeName);
            }

            else if (args[argc].Equals("--publish-item")) {
                    string room = args[argc+1];
                    string collectionName = args[argc+2];
                    string nodeName = args[argc+3];
                    string itemID = args[argc+4];
                    string body = args[argc+5];

                    Dictionary<string, object> itemVO = new Dictionary<string, object>();
                    itemVO.Add("itemID", itemID);
                    itemVO.Add("body", body);
                    am.publishItem(room, collectionName, nodeName, itemVO);
            }

            else if (args[argc].Equals("--retract-item")) {
                    string room = args[argc+1];
                    string collectionName = args[argc+2];
                    string nodeName = args[argc+3];
                    string itemID = args[argc+4];
                    am.retractItem(room, collectionName, nodeName, itemID);
            }
            
            else
                usage(progname);
        }
    }

}
